<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大音希声，大象无形</title>
  
  <subtitle>这深夜里一片寂静，是因为你还没有听见声音</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://changleamazing.com/"/>
  <updated>2020-09-24T13:52:23.999Z</updated>
  <id>http://changleamazing.com/</id>
  
  <author>
    <name>ChangleAmazing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>短链接系统设计</title>
    <link href="http://changleamazing.com/2020/09/24/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://changleamazing.com/2020/09/24/%E7%9F%AD%E9%93%BE%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2020-09-24T13:45:20.000Z</published>
    <updated>2020-09-24T13:52:23.999Z</updated>
    
    <content type="html"><![CDATA[<p>本文会讨论短链接系统设计中的一些关键细节。</p><a id="more"></a><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>短链系统用于为长链接创建较短的别名，这些别名叫做短链接。当用户点击短链接时，他们会被重定向到原始 URL。</p><p>短链接在展示、发送博客时可以节省大量空间，另外，较短的 URL 更方便用户输入。</p><p>例如我们可以通过 <a href="https://tinyurl.com/yx93wn76" target="_blank" rel="noopener">tinyUrl</a> 缩短链接 <a href="https://store.steampowered.com/app/1375870/Comrade_Trumps_Reelection/" target="_blank" rel="noopener">https://store.steampowered.com/app/1375870/Comrade_Trumps_Reelection/</a> 为 <a href="https://tinyurl.com/yx93wn76" target="_blank" rel="noopener">https://tinyurl.com/yx93wn76</a> 。</p><h2 id="系统的要求与目标"><a href="#系统的要求与目标" class="headerlink" title="系统的要求与目标"></a>系统的要求与目标</h2><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol><li>对于给定 URL，服务应该生成一个较短并且唯一的别名。</li><li>用户访问短链接时，服务应该将其重定向到原始链接。</li><li>用户可以为原 URL选择自定义的短链接。</li><li>短链接在默认时间间隔后过期，用户应该能够指定到期时间。</li></ol><h3 id="非功能需求："><a href="#非功能需求：" class="headerlink" title="非功能需求："></a>非功能需求：</h3><ol><li>系统高可用，因为如果服务不可用，会导致所有 URL 重定向失败。</li><li>URL 重定向应该以最小的延迟进行。</li><li>生成的短链接应该是不可预测的。</li></ol><h3 id="扩展要求："><a href="#扩展要求：" class="headerlink" title="扩展要求："></a>扩展要求：</h3><ol><li>分析每个短链接的重定向会发生了多少次？</li><li>服务应该提供 REST API 接口给其他服务调用。</li></ol><h2 id="流量估算与约束"><a href="#流量估算与约束" class="headerlink" title="流量估算与约束"></a>流量估算与约束</h2><p>短链接系统是多读少写的系统。对于生成的短链接会被重定向很多次，假设每个短链接的读写比为 <strong>100:1</strong>。</p><h3 id="流量估算"><a href="#流量估算" class="headerlink" title="流量估算"></a>流量估算</h3><p>假设每个月会生成 <strong>500M</strong> 个新的短链接，由于读写比例为 100:1，所以一个月期望的重定向次数为 <strong>50B</strong>。</p><p>估算短链接生成接口 QPS 为 </p><p>$$<br>500M/ (30 days * 24 hours * 3600 second) ≈ 200 URLs/s<br>$$<br>URL 重定向接口 QPS 为</p><p>$$<br>100 * 200URLs/s = 20K/s<br>$$</p><h3 id="容量估算"><a href="#容量估算" class="headerlink" title="容量估算"></a>容量估算</h3><p><strong>假设每个原始链接及其短链接被存储 5 years</strong>，每个月会有 500M 个新链接产生，所以总共需要存储的对象为：<br>$$<br>500 million * 5 years * 12 months = 30 billion<br>$$</p><p>假设每个原始链接及其短链接大约为 500 个字节，需要的总存储空间为</p><p>$$<br>30 billion * 500 bytes = 15 TB<br>$$</p><h3 id="带宽估算："><a href="#带宽估算：" class="headerlink" title="带宽估算："></a>带宽估算：</h3><p>每秒会传入 200 个新 URL，因此每秒传入服务的数据流量为：</p><p>$$<br>200 * 500 bytes = 100 KB/s<br>$$</p><p>每秒传出的数据流量为：</p><p>$$<br>100 * 100 KB/s = 10MB/s<br>$$</p><h3 id="内存估算"><a href="#内存估算" class="headerlink" title="内存估算"></a>内存估算</h3><p>对于经常访问的热点数据，需要进行缓存。每秒有 20K 的读取请求，因此每天收到的读取总请求数为：</p><p>$$<br>20 K * 24 hours * 3600 seconds ≈ 1.7 billion<br>$$<br>根据二八定律，我们选择缓存其中 20% 的请求，使用到的内存为：</p><p>$$<br>0.2 * 1.7 billion * 500 bytes ≈ 170 GB<br>$$<br>因为在 170 亿请求中，会有大量的重复请求，所以实际使用到的内存会小于 170GB。</p><h3 id="估算汇总"><a href="#估算汇总" class="headerlink" title="估算汇总"></a>估算汇总</h3><p>汇总上述估算数据，得到如下表格：</p><table><thead><tr><th>指标</th><th>数据量</th></tr></thead><tbody><tr><td>新网址数量</td><td>200 /s</td></tr><tr><td>重定向次数</td><td>20 K/s</td></tr><tr><td>输入流量</td><td>100 KB/s</td></tr><tr><td>输出流量</td><td>10 MB/s</td></tr><tr><td>存储五年所需空间</td><td>15 TB</td></tr><tr><td>缓存内存</td><td>170 GB</td></tr></tbody></table><h2 id="API-设计"><a href="#API-设计" class="headerlink" title="API 设计"></a>API 设计</h2><p>当我们确定需求之后，接下来应该开始设计系统 API。</p><h3 id="创建短链接"><a href="#创建短链接" class="headerlink" title="创建短链接"></a>创建短链接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">createUrl</span><span class="params">(String devKey,String originalUrl,String customAlias,String userName,LocalDateTime expireDate)</span></span></span><br></pre></td></tr></table></figure><p>参数意义：</p><ul><li>devKey： API 调用方密钥，用来限制服务调用次数。</li><li>originalUrl：待缩短的原始 URL。</li><li>customAlias：URL 中的自定义字段（可选）</li><li>userName：编码中使用的用户名（可选）</li><li>expireDate：生成的短链接的到期实际（可选）</li></ul><p>成功时返回生成的短链接，失败时返回对应的错误编码。</p><h3 id="删除短链接"><a href="#删除短链接" class="headerlink" title="删除短链接"></a>删除短链接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">deleteUrl</span><span class="params">(String devKey,String urlKey)</span></span></span><br></pre></td></tr></table></figure><p>参数意义：</p><ul><li>devKey：API 调用方密钥</li><li>urlKey：待删除的短链接 URL</li></ul><p>通过 boolean 值返回是否成功，失败时再补充失败消息。</p><h3 id="恶意访问控制"><a href="#恶意访问控制" class="headerlink" title="恶意访问控制"></a>恶意访问控制</h3><p>为了控制暴露的 API 接口被恶意访问，我们通过 devKey 限制用户调用接口数量。</p><p>每个 devKey 只能在一定时间段内创建一定数量的短链接并且会限制短链接的重定向次数。（可以会不同的 devKey 设置不同的限制时间）</p><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><p>我们的系统存储的数据的性质包括：</p><ol><li>每个月产生 5亿个新的 URL，假设在数据库中存储最近一年的数据，则存储的记录总数为 60亿。</li><li>存储的每个对象都很小（1个英文或数字占 1个字节，因此原始链接应该都小于 1K）。</li><li>各个记录之间没有关系。</li><li>记录读写比例很大。</li></ol><p>设计表包括两个：短链接映射表以及用户表</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-09-11-070048.png" alt="表设计" title="">                </div>                <div class="image-caption">表设计</div>            </figure><p>由于存在数十亿的数据，并且记录之间没有依赖关系，所以应该使用 <a href="https://aws.amazon.com/dynamodb/" target="_blank" rel="noopener">DynamoDB</a>/<a href="https://cassandra.apache.org/" target="_blank" rel="noopener">Cassandra</a>/<a href="https://riak.com/" target="_blank" rel="noopener">Riak</a> 这样的 NoSQL 更合适。</p><h2 id="基础系统设计与算法"><a href="#基础系统设计与算法" class="headerlink" title="基础系统设计与算法"></a>基础系统设计与算法</h2><p>对于短链接系统来说，一个重要的xx问题是对于给定的原始链接，如何生成一个唯一并且足够短的链接。</p><h3 id="编码实际的-URL"><a href="#编码实际的-URL" class="headerlink" title="编码实际的 URL"></a>编码实际的 URL</h3><p>我们可以使用 <a href="https://en.wikipedia.org/wiki/MD5" target="_blank" rel="noopener">MD5</a> 或 <a href="https://en.wikipedia.org/wiki/SHA-2" target="_blank" rel="noopener">SHA256</a> 计算原始 URL 的唯一哈希，之后再对哈希散列值进行编码。<strong>我们使用 MD5 作为哈希函数。</strong></p><p>编码方式可以是 <code>base36([a-z,0-9])</code> 或 <code>base62([A-Z,a-z,0-9])</code>，如果需要使用 ‘+’ 与 ‘/‘，则需要使用 <a href="https://en.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64</a> 进行编码。<strong>我们选择使用 base64 编码。</strong></p><p>对于长 6 个字母的键，会有 $64^6 ≈ 687$ 亿个不同字符串。</p><p>对于长 8 个字母的键，会有 $64^8 ≈ 281$ 万亿个不同字符串。</p><p><strong>假设 6 个字母的键已满足我们的要求。</strong></p><p>MD5 产生的哈希值有 128 位。每个 base64 字符会编码 6 位哈希值，所以使用 base64 编码 128 位哈希值，会获得一个超过 21 个字符的字符串。由于短链接只有 6 个字符，我们可以使用编码字符串的前 6 位作为密钥。这样会导致重复密钥，为了解决这个问题，我们可以选择编码字符串中的其它字符或者交换一些字符。</p><h4 id="算法缺陷"><a href="#算法缺陷" class="headerlink" title="算法缺陷"></a>算法缺陷</h4><p>我们的方案存在以下几个问题：</p><ol><li>不同用户输入相同 URL 时，他们会获得相同的短链接，这样是不能接受的。</li><li>未考虑 URL 中的一部分经过编码的问题。</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>当用户输入相同 URL（包括不同用户输入相同 URL，以及相同用户输入部分编码后的 URL）时，我们可以在每个原始 URL 后增加一个递增的序列号使其唯一，然后生成一个哈希值。在存储时不需要存储添加到尾部的序列号。</p><p>这个方案需要注意控制不断递增的序列号不溢出，另外增加序列号会影响服务的性能。</p><p>另一个解决方案是将用户 ID（唯一）附加到原始 URL 中。如果用户未登录，则需要为用户生成唯一密钥，如果生成密钥之后依然存在重复链接，需要继续生成密钥，直到获得唯一的短链接。</p><h3 id="生成离线密钥"><a href="#生成离线密钥" class="headerlink" title="生成离线密钥"></a>生成离线密钥</h3><p>我们可以创建一个独立的密钥生成服务（KGS），类似于发号器。</p><p>该服务可以提前生成随机的六位字符串并将其存在数据库中，每次当用户要生成短链接时，都将返回数据库中的一个字符串。这种方式不用对 URL 进行编码，并且不用担心重复。</p><p>KGS 可以使用两个表来存储密匙：一个表用于存储未使用的密钥，另一个存储已使用的密钥。当 KGS 将密钥提供给某个服务器之后，就可以将该密钥移动至已使用密钥表中。</p><p>KGS 可以始终将一些密钥保留在内存中，提高访问速度。对于加载到内存中的密钥，我们需要先将其移动到已使用密钥表中。如果 KGS 在将密钥标记为已使用与分配至服务器内存之间死亡，将会浪费一部分密钥。不过由于我们可以提前生成大量密钥，对于一部分丢失，是完全可以接受的。</p><h4 id="关注问题"><a href="#关注问题" class="headerlink" title="关注问题"></a>关注问题</h4><ol><li>预先存储密钥的数据库大小</li><li>KGS 单点故障问题</li><li>当多个服务器同时读取密钥时，如何解决并发问题，以防止取到重复的密钥</li></ol><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li><p>使用 base64 编码，可以生成 67.8 billion个唯一的六位字符串密钥。假设我们存储数字字母都只需要一个字节，存储这些键需要的容量为：</p><p>$$<br>6 * 68.7 billion = 412 GB<br>$$</p></li></ol><ol start="2"><li>可以为 KGS 准备一个备用副本。当主服务器死机时，备用服务器就可以接管服务。</li><li>由于 KGS 会预先分配一些密钥到内存中，所以单个服务器分配密钥时不会出现并发问题。关键在于 KGS 服务器向不同服务器分配密钥时，需要利用分布式锁控制分配密钥至不同服务器内存的操作。</li></ol><h2 id="数据分区"><a href="#数据分区" class="headerlink" title="数据分区"></a>数据分区</h2><p>为了扩展数据库，我们需要进行数据分区，以便存储数十亿 URL 信息。</p><h3 id="基于范围的分区"><a href="#基于范围的分区" class="headerlink" title="基于范围的分区"></a>基于范围的分区</h3><p>我们可以基于键的首字母分区。将字母 A 与 a 存在一个分区中，将 B 与 b 存在另一个分区中，依此类推。这种方法称为基于范围的分区。对于不经常出现的字母可以先组合到同一个数据库分区中。</p><p>这种方法的问题在于，它可能会导致数据库服务器不平衡，因为某个字母开头的链接会很多。</p><h3 id="基于散列的分区"><a href="#基于散列的分区" class="headerlink" title="基于散列的分区"></a>基于散列的分区</h3><p>我们可以先对要存储的对象进行哈希计算，之后再根据分区数将 URL 随机分配到不同的分区中，比如设计哈希函数将任意对象映射为 [1…256] 之间的整数，该数字就代表存储对象的分区编号。</p><p>这种方法依赖于哈希算法的随机性来保障分区数据平衡性，不过我们也可以使用<a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C" target="_blank" rel="noopener">一致性哈希</a>来解决哈希分布不均的问题。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>我们可以缓存经常访问的 URL，使用 Redis 存储原始链接及其对应的短链接。在访问数据库之前，应用服务器可以先检查缓存中是否具有所需的 URL。</p><p>由计算得知，大概需要 170 GB 的内存来缓存 20% 的每日流量，这对于服务器来说不算问题。当数据占满缓存，并且我们要用较新的 URL 替换缓存时，我们需要使用缓存淘汰策略。对于我们的系统，使用 LRU 是合理的策略，这样我们会丢弃最近最少使用的 URL。</p><p>为了保证缓存服务器性能，我们可以使用 Redis Cluster 均衡负载。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>系统中由三个位置可以设置负载均衡管理：</p><ol><li>客户端与应用服务器之间</li><li>应用服务器与数据库服务器之间</li><li>应用服务器与缓存服务器之间</li></ol><p>前期可以采用简单的轮询策略，这个策略实现很简单。对于已经宕机的服务器，负载均衡也会将其从循环中移除，停止向其发送任何流量。</p><p>但是当某个服务器过载或者运行缓慢时，轮询策略仍然会向其发送新请求。所以后期我们可以使用一致性哈希或者最小连接数法作为负载均衡算法。</p><h2 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h2><p>由于生成的短链接都是有一定有效期的，如果达到用户指定的到期时间时，链接该如何处理？</p><p>如果我们主动定时搜索过期链接并将其删除，会对数据库造成很大的压力。所以我们可以采取缓慢搜索加上延迟清理策略。</p><ul><li>每当用户尝试访问过期的链接时，都可以删除该过期链接并返回错误给用户</li><li>可以在服务器用户流量较低时，运行一个轻量级的清理服务，从缓存及存储中删除过期链接</li><li>删除过期链接后，可以将密钥放回密钥数据库以便重新使用</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会讨论短链接系统设计中的一些关键细节。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统设计" scheme="http://changleamazing.com/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="System Design" scheme="http://changleamazing.com/tags/System-Design/"/>
    
  </entry>
  
  <entry>
    <title>线程池深入剖析</title>
    <link href="http://changleamazing.com/2020/05/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
    <id>http://changleamazing.com/2020/05/24/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/</id>
    <published>2020-05-24T08:23:57.000Z</published>
    <updated>2020-09-24T13:50:28.380Z</updated>
    
    <content type="html"><![CDATA[<p>从底层深入剖析线程池。</p><a id="more"></a><h2 id="线程池参数"><a href="#线程池参数" class="headerlink" title="线程池参数"></a>线程池参数</h2><p><code>ThreadPoolExecutor</code> 是线程池的核心类，要想深入理解线程池，必须先弄懂这个类。</p><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面三个实际调用的都是第四个构造函数。我们来分析一下第四个构造函数的每个参数：</p><ul><li><p>corePoolSize</p><p>核心线程数，当线程池中的线程数达到这个值时，就会将新的任务放入到缓存队列中</p></li><li><p>maximumPoolSize</p><p>线程池最大线程数，表示线程池中最多能创建的线程个数</p></li><li><p>keepAliveTime</p><p>表示线程池中的非核心线程处于闲暇状态多长时间会被终止。默认情况下，当线程数量大于 corePoolSize 时，该值才会起作用。</p><p>如果调用 <code>allowCoreThreadTimeOut(boolean)</code> 方法，keepAliveTime 不会考虑当前线程池中线程数量</p></li><li><p>unit</p><p>参数 keepAliveTime 的时间单位</p></li><li><p>workQueue</p><p>阻塞队列，用来存储等待执行的任务。包括 <code>ArrayBlockQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code> 和 <code>PriorityBlockingQueue</code>。</p></li><li><p>threadFactory</p><p>用于创建线程的线程工厂</p></li><li><p>handler</p><p>拒绝处理任务时的策略，总共有四种取值：</p><ul><li>AbortPolicy：拒绝提交的任务，并抛出 <code>RejectedExecutionException</code> 异常</li><li>CallerRunsPolicy：使用调用者所在线程执行任务</li><li>DiscardPolicy：丢弃任务</li><li>DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务</li></ul></li></ul><h3 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits(高位存储状态)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><p><code>ctl</code> 是一个 32 位的数字，类型为 <code>AtomicInteger</code>。它包括两部分的信息：线程池的运行状态和活跃线程的数量。</p><p>根据定义的状态常量的值可以判断出 <code>ctl</code> 高 3 位保存运行运行状态。根据 <code>CAPACITY</code> 的值可以知道低 29 位用来保存线程池内活跃线程数，这个常量表示最大线程数量，值为 <code>536870911</code>，实际上开启线程数量不可能达到这么多。</p><p>线程池的运行状态包括以下五种：</p><ol><li>RUNNING：可以接受新提交的任务，并且也能处理阻塞队列中的任务</li><li>SHUTDOWN：不再接受新提交的任务，可以继续处理阻塞队列中保存的任务。调用 <code>shutdown()</code> 方法会使线程池进入此状态</li><li>STOP：不接受新任务也不处理队列中的任务，会中断正在处理任务的线程。调用 <code>shutdownNow()</code> 方法会使线程池进入该状态</li><li>TIDYING：当所有任务终止之后，workCount 为 0，线程池进入该状态后会调用 <code>terminated()</code> 方法进入 <code>TERMINATED</code> 状态</li><li>TERMINATED：在 <code>terminated()</code> 方法执行完成后进入该状态</li></ol><p><code>ThreadPoolExecutor</code> 还提供了几个与 <code>ctl</code> 相关的方法用来获取不同的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; ~CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取活动线程数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行状态和活动线程数的值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs | wc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p><code>execute</code> 方法用来向线程池中提交任务。<code>ThreadPoolExecutor</code> 类中还提供了 <code>submit</code> 用来提交任务，submit 其实也调用了 execute 方法，不过它会将任务包装成 <code>FutureTask</code>，这样可以在之后获取到该线程的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 ctl 值，它记录 runState 和 workerCount</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// workerCountOf(c) 会返回线程池当前活动线程数，如果当前活动线程数小于 corePoolSize，则直接创建新线程</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果创建新线程失败，说明有其它线程被创建了，此时 ctl 值肯定发生改变，所以重新获取</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程池是运行状态并且任务添加到队列成功</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新获取 ctl</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 如果线程池不处于运行状态则需要移除任务，移除成功之后需要使用拒绝策略处理任务。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command)) &#123;</span><br><span class="line">            reject(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果线程池中的有效线程数数量是 0，则创建一个活跃线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 第一个参数为 null 表示不指定任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果线程池不是 running 状态或者加入阻塞队列失败，则创建新线程，扩容至 maxPoolSize。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 创建新线程失败，则执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池执行 execute 的逻辑包括下面几步：</p><ol><li>判断当前运行的线程数是否少于 corePoolSize，如果是，则直接创建新线程来执行新任务</li><li>如果当前运行的线程数量大于或等于 corePoolSize，则将提交的任务存放至阻塞队列中</li><li>如果当前阻塞队列已满且线程个数没有达到最大线程数，则创建新的线程来执行任务</li><li>如果线程池中线程个数超过 <code>maximumPoolsize</code>，则使用拒绝策略 <code>RejectedExecutionHandler</code> 来进行处理</li></ol><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>addWorker 主要工作是在线程池中创建一个新线程并执行。firstTask 参数用于指定新增线程执行的第一个任务，core 参数表示新增线程是否是核心线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">// 循环判断状态</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);<span class="comment">//线程池运行状态</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 如果任务状态值大于等于 SHUTDOWN(SHUTDOWN/STOP/TIDYING/TERMINATED)</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                <span class="comment">//2. 任务状态等于 SHUTDOWN 时，仍然在提交任务或者阻塞队列为空</span></span><br><span class="line">                <span class="comment">// 上面两种情况同时满足时，直接返回 false，无法再新增加线程</span></span><br><span class="line">                !(rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                        firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        !workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层循环，负责新建线程</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">// 活跃线程数量</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">// 判断线程数量是否超过限制。如果 core 为 true，则限制为 corePoolSize，否则限制为 maximumPoolSize</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用 CAS 增加活跃线程数量，成功则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新读取 ctl</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 如果状态不等于之前获取的 state，跳出内层循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) &#123;</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// workerCount 数量增加后续操作</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;<span class="comment">// 线程启动标识</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;<span class="comment">// 线程增加到 workerSet 集合标识</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果线程池在运行或者线程池关闭并且不需要创建新任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 如果线程已经启动了，抛异常</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    workers.add(w);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// largestPoolSize 用来记录线程池容纳的最大线程数</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize) &#123;</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置线程为已添加至集合中</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 集合中添加线程成功，则开启线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!workerStarted) &#123;</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的执行流程为：</p><ol><li>判断线程池当前是否处于可以添加线程的状态，如满足以下三种情况的任意一种，则不允许创建线程，直接返回：<ol><li><code>rs &gt; shutdown</code>。可能为 stop、tidying、terminated</li><li><code>rs == shutdown</code>，并且 <code>firstTask != null</code></li><li><code>rs == shutdown</code>，<code>firstTask == null</code> 而 <code>workQueue.isEmpty == true</code></li></ol></li><li>判断线程池中线程数是否已经达到上限(<code>core ? corePoolSize : maxiumPoolSize</code>)，达到上限则返回 false</li><li>使用 ReentrantLock 向 workerSet 中添加新创建的 worker 线程，添加成功之后启动 worker 线程</li></ol><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>我们需要根据任务的特性来配置线程池参数，才能更好的利用线程池。需要考虑以下几点：</p><ol><li><p>任务性质：CPU 密集型任务或 IO 密集型任务或混合型任务</p><p>CPU 密集型任务是指 CPU 使用率比较高的一些任务，包括计算、内存分配等，这种情况下不应分配大量线程来占用 CPU 资源，所以线程池一般配置 ${N_{cpu}} + 1$ 个线程。对于 IO 密集型任务来说，长时间处于等于等待 IO 操作中，IO 操作只会占用很少的 CPU 资源，所以我们可以分配较多的线程来利用 CPU 处理其他任务，线程池一般配置$2 * {N_{cpu}}$ 个线程。对于混合型的任务，可以将其拆分成一个 CPU 密集型任务与一个 IO 密集型任务，如果这两个任务相差时间不大，我们可以将它们拆分成两个任务，拆分后的吞吐量会高于原来串行执行的吞吐率；如果两个任务时间相差较大，则没有必要分解</p></li><li><p>任务优先级：高或中或低</p><p>对于区分优先级的任务来说，我们可以利用优先队列 <code>PriorityBlockingQueue</code> 来处理，让优先级更高的任务先执行</p></li><li><p>任务执行时间：长或中或短</p><p>执行时间差异较大的任务可以交给不同配置的线程池处理，或者采用优先级队列，让执行时间短的任务先执行</p></li><li><p>任务依赖项：是否依赖其他系统资源</p><p>依赖数据库连接池的任务，同样也是需要等待数据库返回结果，这段时间内 CPU 空闲。如果等待时间越长那么设置的线程数就应该越大，让其它线程利用 CPU。</p></li></ol><h2 id="四种内置线程池"><a href="#四种内置线程池" class="headerlink" title="四种内置线程池"></a>四种内置线程池</h2><p>在知道了线程池的所有参数之后，只要看内置线程池初始化时传的参数就知道这种线程池的运行过程了。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种线程池使用 <code>LinkedBlockingQueue</code> 作为阻塞队列，它默认容量为 <code>Integer.MAX_VALUE</code> ，近乎无界队列，因此线程池拒绝策略没有意义。</p><p>这种线程池的线程数可以设置为 ${N_{cpu}}$ + 1，可以充分利用 CPU 资源，而 IO 较多的任务由于执行时间。由于使用了无界队列，如果任务执行时间过长，而新增任务速率较快，会导致阻塞队列中任务积压过大，最后导致服务器 OOM。所以<strong>这种线程池只适用于任务生产与消费速率相对稳定的并发场景。</strong></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数设置为 0，所以当有任务提交时就会进入阻塞队列中。<code>keepAliveTime</code> 设置为 60s，意味着当线程池中线程在 60s 内没有执行任务就会被销毁。阻塞队列使用 <code>SynchronousQueue</code>，该队列没有存储空间，当有新请求进来时，会去寻找空闲线程执行该任务，如果没有找到，则创建一个新线程来执行任务。这些特性使得该线程池在空闲时占用资源较少，因为会自动回收线程。<strong>它适合处理执行时间少且任务速度提交较慢的场景</strong>，否则会不断创建新线程执行任务，可能导致系统 CPU 和内存资源耗尽。</p><p><strong>这种线程池不推荐在生产环境中使用，如果在 60s 内任务激增，可能会导致服务器宕机。</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数与最大线程数都设置为 1，阻塞队列为 <code>LinkedBlockingQueue</code> ，所以性质与 <code>newFixedThreadPool</code> 差不多。不过该线程池会始终保持线程池中活跃线程数为 1。所以如果这个线程在执行任务时发生异常，也会创建新的线程来继续完成任务。所有的任务会按照顺序被执行。</p><p><strong>这种线程池适合需要按顺序执行的非核心逻辑的任务，比如日志记录等功能。</strong></p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心线程数为设置的值，最大线程数为 <code>Integer.MAX_VALUE</code>。阻塞队列为 <code>DelayedWorkQueue</code>，同样为无界队列。该队列中封装了一个优先级队列，会对队列中的任务进行排序，距离执行时间短的任务优先级高。</p><p>该线程池提供了两个方法：</p><ul><li>scheduledAtFixedRate：任务开始执行时开始计算时间</li><li>scheduledWithFixedDelay：任务执行完成后开始计算时间</li></ul><p><strong>该线程池用于需要多个后台线程执行周期任务，同时需要限制线程数量的场景。不过在生产中执行周期任务一般使用定时任务来处理。</strong></p><h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue 是有界队列，容量是自定义的，使用数组实现，执行顺序为 FIFO。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue 的基于链表实现，它的容量也是自定义的，默认为 <code>Integer.MAX_VALUE</code>，相当于一个无界队列。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue 是一个任务按固定周期执行的优先级队列。根据任务将要被执行的时间远近排序，否则根据插入到队列的先后顺序排序。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue 是具有优先级队列的无界阻塞队列。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是不存储元素的队列，每个插入操作必须等待另一个线程调用取出操作，否则后续插入操作一直被阻塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从底层深入剖析线程池。&lt;/p&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="http://changleamazing.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="ThreadPool" scheme="http://changleamazing.com/tags/ThreadPool/"/>
    
  </entry>
  
  <entry>
    <title>一致性协议</title>
    <link href="http://changleamazing.com/2020/05/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/"/>
    <id>http://changleamazing.com/2020/05/16/%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-05-16T09:04:24.000Z</published>
    <updated>2020-05-16T19:07:17.764Z</updated>
    
    <content type="html"><![CDATA[<p>本文会分析经典的 2PC、3PC 以及 Paxos 算法来了解分布式系统的数据一致性协议。</p><a id="more"></a><p>在分布式系统中，通过网络请求其它服务的接口，总共会有三种情况：正确、失败和超时。其中正确和失败我们都能确定被调用服务的执行情况，但是<strong>在接口调用超时的情况下，调用方不能确定被调用方是否成功处理了请求</strong>，这一点造成了分布式系统中的许多问题。</p><p>通过对 CAP 定理的分析，可以知道分布式系统主要是对系统的可用性和数据一致性之间进行权衡，因此产生了一系列的一致性协议。我们来看看一些经典的一致性协议是如何解决上述的服务调用超时问题的。 </p><h2 id="2PC-与-3PC"><a href="#2PC-与-3PC" class="headerlink" title="2PC 与 3PC"></a>2PC 与 3PC</h2><p>在一个分布式系统中，每个节点都只知道自己的执行情况，并不知道其他节点的执行情况，所以我们需要引入协调者（Coordinator）来统一调度所有节点的执行逻辑，这些被调度的分布式节点则被称为参与者（Participant）。</p><p>协调者负责调度参与者的行为，并最终决定这些参与者是否需要提交事务。基于这个思想，产生了二阶段提交（2PC）与三阶段提交（3PC）两种协议。</p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p><strong>分布式系统中的一致性协议都是基于两阶段提交进行的改进</strong>。</p><p>2PC 将执行过程分为了两个阶段，投票阶段与提交阶段。</p><h4 id="投票阶段"><a href="#投票阶段" class="headerlink" title="投票阶段"></a>投票阶段</h4><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-16-190627.jpg" alt="2PC VOTING PHASE" style="zoom:25%;" /><p>如图所示，在投票阶段分为三个步骤：</p><ol><li>协调者会询问所有的参与者是否可以执行提交</li><li>各参与者节点执行事务操作，并记录Undo（回滚）和 Redo（重试）日志</li><li>各参与者向协调者反馈执行操作的结果</li></ol><h4 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h4><p><strong>当所有的参与者都返回了确定的结果（同意或终止）时</strong>，2PC 进入提交阶段。</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-16-190615.jpg" alt="2PC COMMIT PHASE" style="zoom:25%;" /><p>提交阶段分为四个步骤：</p><ol><li>协调者根据投票阶段是否有参与者返回失败来决定发送 Commit 请求还是 Rollback 请求</li><li>参与者接收到协调者发送的请求后，如果是 Commit，会执行该节点的事务提交操作，并释放占用的资源；如果是 Rollback，会根据投票阶段该节点记录的 Undo 日志执行事务回滚操作，并释放占用的资源</li><li>参与在完成相应的事务操作之后，向协调者发送 ACK 消息</li><li>协调者接收到所有参与者反馈的 ACK 消息之后，完成操作</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>2PC 的优点在于原理简单且实现方便。</p><p>但是缺点也很明显，由于 2PC 是同步阻塞协议，如果在投票阶段，当参与者处于事务执行阶段时，协调者发生了永久宕机，此时参与者将永远无法完成事务，因为它们会一直等待 Commit/Rollback 请求。</p><p>另一点是数据不一致问题，如果在提交阶段，当协调者向所有参与者发送 Commit 请求时，如果此时部分参与者出现故障，或者协调者在向部分节点发送 Commit 请求后自身故障，会出现系统中部分参与者提交了事务，而其他参与者仍然没有进行事务提交，导致系统中出现了数据不一致的现象。</p><h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-16-182356.png" alt="3PC" style="zoom:25%;" /><p>3PC 是在 2PC 的基础上改进的，它将 2PC 的投票阶段中的询问与执行事务拆分为两个阶段。形成了由 canCommit、preCommit 和 doCommit 三个阶段组成的协议。</p><p>3PC 主要对 2PC 进行了两处改动，首先是将 2PC 投票阶段拆分成两个阶段之后，降低了阻塞范围。3PC 最大的改动是引入了超时和节点宕机的处理机制。</p><p><strong>节点在超时后会根据阶段来决定是否提交事务</strong>，比如在第三阶段中，某个参与者没有收到协调者的 commit 请求，它会自动提交事务。因为在第二阶段协调者既然能发出 commit 请求，就说明第一阶段中所有节点都认为自己能够执行事务，所以该参与者会认为在绝大概率情况下，其它参与者第二阶段也能正确执行事务，并向协调者发送 ACK 。</p><p><strong>节点在宕机后会根据另一方接下来的操作来决定重启后的操作</strong>。依然用第三阶段举例，假设当所有参与者都向协调者发送了 ACK 之后，协调者将向参与者发送 commit 请求，而此时协调者直接宕机。由于存在超时处理机制，在第三阶段各个参与者一直收不到 commit 请求也会自己提交事务。所以协调者在宕机恢复之后默认所有的参与者已经自动提交事务，因此协调者会完成事务，正确结束。</p><p>对于参与者来说，则是判断下一步协调者会发出的指令，并作出对应的操作。</p><p>这篇来自弗吉尼亚理工大学的名为 <a href="http://courses.cs.vt.edu/~cs5204/fall00/distributedDBMS/sreenu/3pc.html" target="_blank" rel="noopener">Three-Phase Commit Protocol</a> 的文章对 3PC 的各种情形都做了详细的描述，推荐一看。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>3PC 仍然存在数据不一致的问题，由于第三阶段中参与者的超时处理逻辑为自动提交，如果协调者真正向其他参与者发送的请求为 rollback，那么就会导致该自动提交的参与者与其他参与者数据不一致。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul><li><a href="http://courses.cs.vt.edu/~cs5204/fall00/distributedDBMS/sreenu/3pc.html" target="_blank" rel="noopener">Three-Phase Commit Protocol</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文会分析经典的 2PC、3PC 以及 Paxos 算法来了解分布式系统的数据一致性协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://changleamazing.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Distributed Theory" scheme="http://changleamazing.com/tags/Distributed-Theory/"/>
    
  </entry>
  
  <entry>
    <title>CAP 定理与 BASE 理论</title>
    <link href="http://changleamazing.com/2020/05/14/CAP%20%E5%AE%9A%E7%90%86%E4%B8%8E%20BASE%20%E7%90%86%E8%AE%BA/"/>
    <id>http://changleamazing.com/2020/05/14/CAP%20%E5%AE%9A%E7%90%86%E4%B8%8E%20BASE%20%E7%90%86%E8%AE%BA/</id>
    <published>2020-05-14T12:29:56.000Z</published>
    <updated>2020-05-14T13:11:23.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><p>CAP 定理原来是科学家埃里克·布鲁尔提出的一个猜想，之后被赛斯·吉尔伯特和南希·林奇证明，成为了一个定理。</p><p>CAP 定理指出对于一个分布式系统，不可能同时满足以下三点：</p><ul><li>一致性（Consistence）：数据在多个节点之间能保持一致的特性，</li><li>可用性（Availability）：系统必须一直处于可用的状态，每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据</li><li>分区容错性（Partition tolerance）：系统节点之间由于网络问题产生了分区时仍然能保持正常服务</li></ul><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-13-195638.jpg" alt="CAP  5:14:2020" style="zoom:33%;" /><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>下面证明一下为什么三个特性不能同时存在。</p><p>保证 AP：在分布式系统产生分区时，保持每个节点都对外提供服务，但是这种情况下节点内部通信时间延长或者失败，导致它们无法同步最新的数据，无法满足 C。</p><p>保证 CP：在分布式系统产生分区时，保证不同节点中的数据一致。如果节点对外继续提供服务，则可能产生新的数据，导致与其他节点数据不一致，为了保证一致性，需要对外提供服务的节点返回系统处理失败，无法满足 A。</p><p>对于分布式系统来说，保证 CA 的系统比较特殊，由上面两种情况可以知道，无法在存在分区的情况下还能保证系统的 CA 特性。那存不存在完全不会产生分区的分布式系统呢？假设一台机器每年宕机一天，那么一个包含 365 个节点的系统就可能每天都会产生宕机，除此之外还有运营商网络通信的异常，所以 P 是无法忽视的。</p><p>由于分区是否产生不受我们的控制，所以一般认为 P 是必须提供的，因此这个 CAP 定理可以转化为以下描述：</p><p><strong>在系统满足分区容忍性的情况下，要么保证数据一致性，要么保证可用性。</strong></p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-14-090450.jpg" alt="AC Switch" style="zoom:33%;" /><p> 如上图所示，P 存在的情况下，AC 只能二选一。</p><h3 id="AP-与-CP-的应用"><a href="#AP-与-CP-的应用" class="headerlink" title="AP 与 CP 的应用"></a>AP 与 CP 的应用</h3><p>AP 与 CP 的选择我们可以从 C 来考虑，CAP 中的 C 是数据的强一致性，一般来说，涉及到金融相关的系统是必须保证数据的强一致性的，否则会造成经济损失。</p><p>对于一般的系统，由于互联网应用主机众多，并且部署分散，集群规模越来越大，所以节点故障与网络故障是常态。为了保证服务可用性达到 N 个 9 的指标，则需要舍弃 C，保证 AP，通过后续的处理保证数据达到最终一致性即可。</p><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><p>BASE 表示 Basically Available（基本可用）、Soft state（软状态）和 Eventually Consistent（最终一致性）。</p><p>BASE 来源于对大规模互联网系统分布式实践的总结， 是对 CAP 中一致性与可用性权衡的结果。</p><p>BASE 理论核心思想是 <strong>即使无法做到强一致性，但每个应用都可以根据业务特点，采用适当的方式使系统达到最终一致性。</strong></p><ul><li><p>基本可用</p><p>基本可用是指分布式系统在出现不可预知的故障时，允许损失部分可用性。</p><p>例如：</p><ul><li>响应时间损失：当系统部分机房出现故障时，查询接口的响应时间从原来的 0.5s 延长到 1~2s</li><li>功能损失：当电商系统抢购时，由于并发数量激增，为了保护系统的稳定性，部分消费者可能会被引导到一个降级页面</li></ul></li></ul><ul><li><p>软状态</p><p>软状态是指允许系统中的数据存在中间状态，并且该中间状态不会影响系统整体可用性，即允许系统在不同节点的数据副本之间的同步存在延时。</p></li></ul><ul><li><p>最终一致性</p><p>最终一致性是指系统中所有的数据副本，在经过一段时间的同步后，最终能保证所有副本数据一致。在进行同步的这段时间内，系统中的数据就会存在中间状态，系统处于软状态。</p></li></ul><p>关系型数据库大多都会采用同步和异步的方式来实现主备数据复制技术。对于异步方式来说，备库的更新往往会存在延时，这取决于事务日志在主备数据库之间传输的时间长短。如果传输时间过长或者传输过程中出现异常，都会导致这一段时间内主备数据不一致。我们可以采用多次重试或者人工操作来订正备库数据，最终主备库数据能够达成一致。需要注意的是，多次重试一般都是有次数限制的，所以完善的分布式系统一定要对系统异常进行监控，及时采用人工措施去处理，否则系统处于软状态的时间过长，就可能会造成严重的损失。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CAP-定理&quot;&gt;&lt;a href=&quot;#CAP-定理&quot; class=&quot;headerlink&quot; title=&quot;CAP 定理&quot;&gt;&lt;/a&gt;CAP 定理&lt;/h2&gt;&lt;p&gt;CAP 定理原来是科学家埃里克·布鲁尔提出的一个猜想，之后被赛斯·吉尔伯特和南希·林奇证明，成为了一个定理。
      
    
    </summary>
    
    
      <category term="分布式系统" scheme="http://changleamazing.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Distributed Theory" scheme="http://changleamazing.com/tags/Distributed-Theory/"/>
    
  </entry>
  
  <entry>
    <title>MySQL BTREE 索引分析</title>
    <link href="http://changleamazing.com/2020/05/11/BTREE%20%E7%B4%A2%E5%BC%95/"/>
    <id>http://changleamazing.com/2020/05/11/BTREE%20%E7%B4%A2%E5%BC%95/</id>
    <published>2020-05-10T17:11:18.000Z</published>
    <updated>2020-05-10T17:12:01.943Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要基于 InnoDB 的 BTREE 索引来分析索引。</p><a id="more"></a><blockquote><p>索引是帮助 MySQL 高效获取数据的数据结构</p></blockquote><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="磁盘-IO"><a href="#磁盘-IO" class="headerlink" title="磁盘 IO"></a>磁盘 IO</h3><p>先看一下磁盘的结构：</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-142445.gif" alt="磁盘结构" style="zoom:67%;" /><p>一块磁盘有多个磁道组成，磁道上的每一个弧段即为一个扇区，扇区大小一般为 512B。</p><p>InnoDB 的数据存储在磁盘上，磁盘读取数据依靠的是机械运动。每次读取数据时间 = 寻道时间 + 旋转延迟 + 传输时间。</p><p>寻道时间指磁头移动到指定磁道所需要的时间，一般在 5ms 左右；</p><p>旋转延迟是指磁盘在磁道上找到指定扇区所需要花费的时间，假设磁盘转速为 7200 转/min，则每秒钟可以转 120 圈，磁头旋转到离当前位置最远的扇区（即磁盘对面）需要转半圈，所以旋转延迟最大为：1/2/120 = 4.17 ms；</p><p>传输时间是指与磁盘进行读写交互的时间，系统每一次读取磁盘是以页(逻辑概念，对应物理概念为盘块，即多个扇区,<strong>大小默认为</strong> <strong>4KB</strong>)为单位,读取花费时间大概在 0.3 ms 左右。</p><p>页大小通过命令 <code>getconf PAGE_SIZE</code> 获取：</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-145926.png" alt="image-20200510225926632" style="zoom:40%;" /><p>根据 <a href="https://baike.baidu.com/item/%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/3334556?fr=aladdin" target="_blank" rel="noopener">局部性原理</a> 来说，计算机访问一个地址的数据时，与其相邻的数据很快也会被访问到，所以操作系统针对此进行了优化，在传输数据时，以页为单位读取数据，这样很在访问同一页内的数据时，只会发生一次磁盘 IO，大大减少了读取数据总耗时。这个理论对于索引的数据结构设计非常有帮助。</p><h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-155751.png" alt="B+树" title="">                </div>                <div class="image-caption">B+树</div>            </figure><p>索引的结构如图所示，是一颗 b+ 树。图中每一个节点称为一个数据页（<strong>默认为 16K</strong>，这是 MySQL 磁盘管理的最小单位，与操作系统页大小不同），每个数据页中都包含若干个数据项，对于非叶子节点来说，数据项为指引搜索方向的指针；对于叶子节点来说，存储的是实际数据。</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-155202.png" alt="image-20200510235202821" style="zoom:47%;" /><p>从根节点开始从 b+ 树中找到所需数据需要的 IO 次数不超过层数。而当数据量一定时，每个节点中存储的指针项越多，b+ 树的层数越少，这样查找数据的 IO 次数也会变少，性能大幅提升。</p><p>有了上述理论之后，这里引入一个 b+ 树与 b 树的区别：<strong>b+ 树中非叶子节点只存储指针，不存储实际数据；而 b 树的非叶子节点中既存储指针，又存储数据。</strong></p><p>因为 b+ 树这样的设计，可以保证在同一个数据页中，可以存储更多的数据项，从而使得 b+ 树层数更少，因此 IO 次数更少，查找数据性能更强。</p><h2 id="聚集索引与辅助索引"><a href="#聚集索引与辅助索引" class="headerlink" title="聚集索引与辅助索引"></a>聚集索引与辅助索引</h2><p>存在一张表，建表语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE users(</span><br><span class="line">    id INT NOT NULL,</span><br><span class="line">    first_name VARCHAR(20) NOT NULL,</span><br><span class="line">    last_name VARCHAR(20) NOT NULL,</span><br><span class="line">    age INT NOT NULL,</span><br><span class="line">    PRIMARY KEY(id),</span><br><span class="line">    KEY(last_name, first_name, age)</span><br><span class="line">    KEY(first_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>聚集索引是指根据表中主键顺序构建的一颗 b+ 树，并且在叶子节点中存放表的行记录。</p><p>表中没有指定主键时，根据顺序取唯一索引的第一列作为聚集索引的键；如果表中不存在唯一索引时，MySQL 会新建一个隐藏列，对不同的行设定序号来构建聚集索引。</p></blockquote><p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-161023.png" alt="聚集索引"></p><p><strong>这里只是为了表现聚集索引的特点，所以结构上忽略了一些特性，如连接叶子节点的链表等。</strong></p><p>从图上可以知道，聚集索引的叶子节点保存了整行数据，而不是其中的一部分，所以聚集索引构成的 b+ 树也就是表数据存储的形式。所有正常的表有且仅有一个聚集索引。</p><p>辅助索引也是通过 b+ 树实现的，但是其叶子节点并不包括行记录全部数据，只会包括索引中的键以及聚集索引中的键。辅助索引用于加速数据查找，所以一张表上往往建立多个辅助索引来提升数据库的性能。但是辅助索引数量一般不超过 5 个，否则修改数据时，维护索引的时间会大大影响数据库操作的性能。</p><p>假设数据库存在辅助索引（first_name,age)，则该索引构成的 b+ 树会如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-10-162059.png" alt="辅助索引" title="">                </div>                <div class="image-caption">辅助索引</div>            </figure><p>可以看到，其叶子节点中存放的数据包括索引列 <code>first_name,age</code> 与该表的聚集索引键 <code>id</code>。当查找到 <code>id</code> 后，会再去聚集索引中根据 <code>id</code> 获取整行记录。</p><h2 id="索引注意事项"><a href="#索引注意事项" class="headerlink" title="索引注意事项"></a>索引注意事项</h2><ul><li><p>遵循最左前缀匹配原则</p><p>MySQL 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。比如存在（a,b,c,d）顺序的索引，查询条件为 <code>a = 1 and b = 2 and c &gt; 3 and d = 4</code> ，d 无法使用索引。</p></li><li><p>选择区分度高的列作为索引列</p><p>区分度计算公式为 <code>count(distinct col)/count(*)</code>，表示字段不重复的比例。如果某索引列中重复数据很多，需要扫描很多次辅助索引表，再去主键索引中查找对应数据，很可能超过了全表扫描获取数据的时间。</p></li><li><p>索引不会包含含有 NULL 值的列</p><p>因为 NULL 无法参与计算，因此也无法构建 b+ 树</p></li><li><p>使用短索引</p><p>对一个字符串列创建索引时，很可能前几位就能区别出大多数数据，那就根据这几位来创建索引，而不是用整列创建索引。因为索引键也要存储在磁盘上，减少索引键长度可以节省磁盘并且减少 IO 操作</p></li><li><p>索引列不应该参与运算</p><p>因为索引键存的是列原始值，如果对列进行运算，得到的结果是无法在索引中直接找到的，需要对索引所有键都进行运算，而这个开销可能早已超过全表扫描了</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://draveness.me/mysql-innodb/" target="_blank" rel="noopener">『浅入浅出』MySQL 和 InnoDB</a></li><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">  MySQL索引原理及慢查询优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要基于 InnoDB 的 BTREE 索引来分析索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="http://changleamazing.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://changleamazing.com/tags/MySQL/"/>
    
      <category term="DataBase" scheme="http://changleamazing.com/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>AQS 源码分析</title>
    <link href="http://changleamazing.com/2020/05/07/AQS%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://changleamazing.com/2020/05/07/AQS%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-05-06T23:31:17.000Z</published>
    <updated>2020-05-10T06:27:01.386Z</updated>
    
    <content type="html"><![CDATA[<p>AQS（AbstractQueuedSynchronizer）是一个用来构建锁和同步器的框架，它底层使用 CAS 技术来保证操作的原子性，同时利用 FIFO 队列实现线程间的锁竞争，它是 J.U.C 并发包同步的核心基础组件，是 ReentrantLock、CountDownLatch 等同步工具的底层实现机制。</p><a id="more"></a><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先介绍 AQS 的重要属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 头结点，即当前持有锁的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞的尾结点，每次有新的节点，都会被插入到队列尾</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代表当前锁的状态</span></span><br><span class="line"><span class="comment"> * 0：没有被占用；&gt;0：表示有线程持有当前锁（&gt;1 表示有锁被某线程重入）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>这几个属性都被 <code>volatile</code> 修饰，确保多线程间字段的可见性。</p><p>head 与 tail 容易理解，state 用来记录锁的同步状态，等于 0 表示无锁；大于 0 表示有锁，并且每次加锁 state 会增加 1，释放锁则会减 1。</p><p>AQS 提供了独占锁与共享锁，ReentrantLock 就是一种独占锁的实现，而 CountDownLatch 和 Semaphore 则是共享锁的实现。</p><p>接下来介绍 AQS 中阻塞队列的结构。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-29-104057.png" alt="CLH" title="">                </div>                <div class="image-caption">CLH</div>            </figure><p>如图所示，这是一个双向队列，其中每个节点表示等待获取锁的线程,对应 AQS 中的内部类 Node，它们都有一个 waitStatus 属性，表示等待状态，共包括四种值：</p><ol><li><p>CANCELLED    1</p><p> 取消状态，表示当前节点已经等待超时或者已经被中断了，需要被移除。</p></li><li><p>SIGNAL           -1</p><p> 等待触发状态，表示后继节点对应的线程需要被唤醒</p></li><li><p>CONDITION    -2</p><p> 等待条件状态，表示当前节点在 condition 队列中</p></li><li><p>PROPAGATE   -3</p><p> 状态向后传播，表示状态会被传播给后续节点，仅在共享锁模式下使用</p></li></ol><h2 id="独占锁"><a href="#独占锁" class="headerlink" title="独占锁"></a>独占锁</h2><h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>如果某个线程获取到了独占锁，那么其它线程初次尝试获取锁时会失败，然后进入等待队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            <span class="comment">// 放入阻塞队列</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法进来就会调用 <code>tryAcquire</code> 尝试获取锁，如果获取锁失败，则将当前线程封装成节点加入队列尾部。</p><p>跟踪将节点加入队尾的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 尝试直接设置为队列尾节点（因为大部分情况下尾节点不为空，CAS 设置也不会失败）</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// pred（此处即 tail）!= null 说明队列不为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护 node 前置节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 CAS 将节点设置为队列尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 维护 pred 的后置节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入此处说明阻塞队列为空或者 CAS 失败（其它线程在竞争入队）</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter 方法在调用 enq 方法之前进行了一次尾节点不为空的判断，事实上没有这次判断 enq 方法也能保证该节点加入等待队列。但是由于在实际使用场景中，大多数情况下尾节点都不为空且使用 CAS 操作都不会失败，所以这里直接将新节点设置为尾节点的操作就会成功，也不用再进入 enq 方法使用自旋来添加尾节点。</p><p>我们再进入 enq 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 循环保证节点一定添加成功</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 尾节点为空说明队列为空，使用 CAS 设置 head</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) &#123;</span><br><span class="line">                <span class="comment">// 暂时设置 tail = head，但是没有 return，继续循环，进入 else 分支</span></span><br><span class="line">                tail = head;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将当前线程对应的节点插入队列尾，自旋保证一定成功</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq 方法直接开始自旋，保证节点一定入队成功。</p><p>addWaiter 中尝试直接设置尾结点失败总共只有两种原因，enq 方法就对这两种原因进行处理。针对尾节点为空的情况，使用 CAS 设置头节点，之后会开启下次循环。针对尾节点不为空而 CAS 失败的情况，则继续尝试使用 CAS 来插入队尾。</p><p>执行完该方法，节点已经被添加到等待队列队尾了，接下来执行 acquireQueued 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果 node 前置节点为 head ，则尝试获取锁，因为 head 节点有可能是在 enq 方法中刚刚初始化，</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功需要将该节点设置为 head</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将原头节点与其后继节点断联</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 node 前置节点不是 head 或者获取锁失败，进入挂起逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    <span class="comment">//阻塞线程并返回线程是否被中断</span></span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 在 tryAcquire(arg) 抛异常时，failed = true</span></span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquireQueued 方法主要包括两个步骤：</p><ol><li>如果 node 前置节点为 head，则尝试获取锁</li><li>如果 node 前置节点不是 head 或者获取锁失败，则进入挂起逻辑</li></ol><p>进入判断是否需要被挂起的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前置节点状态 ws = -1，需要挂起当前线程，直接返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ws &gt; 0，则需要删除前置节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 由于队列中的线程被挂起之后，是由前置节点唤醒的。所以需要将该节点的前置节点设置为一个正常状态的节点</span></span><br><span class="line"><span class="comment">         从 pred 开始向前遍历，删除 waitStatus &gt; 0 的结点，直到找到某个线程未被取消的节点 */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 等价于 pred = pred.prev; node.prev = pred;</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  进入这里说明 ws 只可能是 0，-2，-3</span></span><br><span class="line"><span class="comment">         *  每个 node 进入队列时，waitStatus 都是默认值 0，在这里将前驱节点的 waitStatus 设置为 -1。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire 用来判断当前节点是否应当挂起。</p><p>主要包括以下几个操作：</p><ol><li>判断前置节点 pred 状态。如果为 SIGNAL，则直接返回 true，表示应该挂起该节点</li><li>如果 pred 节点状态为 CANCELLED  ，从前置节点 pred 开始向前删除状态为 CANCELLED 的节点</li><li>如果 pred 状态不是上述状态，则将它设置为 SIGNAL，之后会在 acquireQueued 中再循环一次</li></ol><p>进入挂起方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 LockSupport 原语来阻塞线程。</p><p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-05-07-021456.jpg" alt="获取锁过程"></p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁定同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head 不为空且 waitStaus != 0 则唤醒后继节点（waitStatus == 0 表示没有后继节点）</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) &#123;</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入释放后继节点的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 head 节点 waitStatus &lt; 0 ，使用 CAS 修改为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取直接后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果后继节点为空或者后继节点取消了等待（waitStatus == 1），则从尾部开始向前遍历，直到找到距离 node 节点最近的 ws&lt;=0 的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从后往前遍历可以确保访问到新增加的结点。</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> #addWaiter(Node)&#125; 方法中，新节点插入的时候，首先就维护了前置结点，再设置到队列中，</span></span><br><span class="line"><span class="comment">         * 而设置 pred.next = node 并不是原子操作，所以从后遍历，能够保证访问到刚入队的结点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果 head.waitStatus &lt; 0，会使用 CAS 将它设置为初始状态。之后唤醒后继节点，如果直接后继节点为空，则尝试从队尾开始向前寻找第一个符合条件的节点。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><h3 id="获取锁-1"><a href="#获取锁-1" class="headerlink" title="获取锁"></a>获取锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//  尝试获取共享锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行获取锁失败的逻辑</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试获取锁，失败则进入获取锁失败的逻辑中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建共享锁节点，准备添加到队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 与独占锁类似，前置结点为头节点，直接尝试获取锁</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 共享锁唤醒逻辑</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 挂起逻辑，与独占锁相同</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt()) &#123;</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) &#123;</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个流程与独占锁构建节点并入队的逻辑一致，只是在此处，获取锁成功之后，会调用 <code>setHeadAndPropagate</code> 方法尝试唤醒后继节点，实现共享。</p><p>进入 setHeadAndPropagate 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);<span class="comment">// 设置头节点</span></span><br><span class="line">    <span class="comment">// 根据状态判断是否唤醒后继线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是设置头节点，并唤醒头节点的后继线程。此处最重要的是进入唤醒后继线程的条件，后续会分析。</p><p>进入唤醒后继线程的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果队列中存在后继节点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 更新状态为 0</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 唤醒直接后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 head 状态为 0，使用 CAS 更新为 PROPAGATE 保证唤醒后继节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环过程中 head 节点是否变化，如果不是，需要重新开始循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放锁-1"><a href="#释放锁-1" class="headerlink" title="释放锁"></a>释放锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里释放成功会调用 <code>doReleaseShared</code> 释放后继节点</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="节点入队顺序问题"><a href="#节点入队顺序问题" class="headerlink" title="节点入队顺序问题"></a>节点入队顺序问题</h3><p>在 enq 方法中，存在以下代码片段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">node.prev = t;</span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">    t.next = node;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是先将元素入队，再通过 CAS 设置尾结点。这样能保证队列数据统一。如果先通过 CAS 设置尾节点，再将其与前面的元素绑定，则在绑定前的一瞬间内，CAS 队列中存在尾节点，其前置节点为空的情况，这与实际数据不符。</p><h3 id="节点遍历问题"><a href="#节点遍历问题" class="headerlink" title="节点遍历问题"></a>节点遍历问题</h3><p>唤醒节点的方法 <code>unparkSuccessor</code> 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 head 节点 waitStatus &lt; 0 ，使用 CAS 修改为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取直接后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果后继节点为空或者后继节点取消了等待（waitStatus == 1），则从尾部开始向前遍历，直到找到距离 node 节点最近的 ws&lt;=0 的节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从后往前遍历可以确保访问到新增加的结点。</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> #addWaiter(Node)&#125; 方法中，新节点插入的时候，首先就维护了前置结点，再设置到队列中，</span></span><br><span class="line"><span class="comment">         * 而设置 pred.next = node 并不是原子操作，所以从后遍历，能够保证访问到刚入队的结点。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                s = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从后向前的遍历顺序其实也要关注插入节点的顺序：</p><ol><li>设置新节点的前置节点为原尾节点</li><li>CAS 设置新节点为尾节点</li><li>设置原尾节点的后继节点为新节点</li></ol><p>考虑以下情况：</p><ol><li>node 在此刻为 tail，因此存在 s == null</li><li>有新节点通过 enq 方法入队</li><li>在入队时只执行了插入节点三个步骤中的前两步，还没有执行第三步</li><li>此刻如果从 node 开始向后遍历，会得到 node 的后继节点为空，所以直接返回</li></ol><p>由于节点入队时优先设置的前继节点，所以从 tail 开始向前遍历，可以保证在 CAS 设置 tail 元素成功之后即可遍历到最新入队的节点，而不需要三步都执行完，这样尽可能的保证了队列元素的完整性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>AQS 的设计十分精妙，这样简单的分析无法体会到精髓，也很难深入理解，后续会继续剖析基于 AQS 实现的 JUC 同步工具类，弄懂如何基于 AQS 简单的实现同步。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AQS源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AQS（AbstractQueuedSynchronizer）是一个用来构建锁和同步器的框架，它底层使用 CAS 技术来保证操作的原子性，同时利用 FIFO 队列实现线程间的锁竞争，它是 J.U.C 并发包同步的核心基础组件，是 ReentrantLock、CountDownLatch 等同步工具的底层实现机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Concurrency,SourceCode" scheme="http://changleamazing.com/categories/Concurrency-SourceCode/"/>
    
    
      <category term="JDK" scheme="http://changleamazing.com/tags/JDK/"/>
    
      <category term="SourceCode" scheme="http://changleamazing.com/tags/SourceCode/"/>
    
  </entry>
  
  <entry>
    <title>Spring IoC 容器源码分析</title>
    <link href="http://changleamazing.com/2020/04/23/SpringIoC%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%8A/"/>
    <id>http://changleamazing.com/2020/04/23/SpringIoC%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E4%B8%8A/</id>
    <published>2020-04-22T20:04:29.000Z</published>
    <updated>2020-05-10T06:27:33.554Z</updated>
    
    <content type="html"><![CDATA[<p><code>Ioc</code> 是 <code>Spring</code> 中重要的概念，本文以 <code>ClassPathXmlApplicationContext</code> 为例，结合源代码深入分析 <code>IoC</code> 容器的实现。</p><a id="more"></a><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>新建一个 <code>maven</code> 项目来启动 <code>Spring</code> 容器，只需要在 <code>pom.xml</code> 中引入 <code>spring-context</code> 依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.0.16.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>构建 <code>ApplicationContext</code> 有多种方式，首先看一下 <code>ApplicationContext</code> 的类结构。</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-22-115740.jpg" alt="ApplicationContext 类结构" style="zoom: 50%;" /><p>我们可以选用三种方式来启动 Spring 容器：</p><ol><li>ClassPathXmlApplicationContext：在 ClassPath 中加载 xml 配置文件。</li><li>FileSystemXmlApplicationContext：通过系统路径加载 xml 配置文件。</li><li>AnnotationConfigApplicationContext：基于注解使用</li></ol><p>本文选择使用 <code>ClassPathXmlApplicationContext</code> 来启动 Spring 容器。</p><p>首先定义一个接口以及对应的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来在 resource 目录下新建 xml 配置文件，文件名为：application-context.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.zcl.service.impl.MessageServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来就可以使用 Demo 从 xml 文件中获取 <code>ApplicationContext</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">        MessageService messageService = context.getBean(MessageService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Resource[] configResources;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Demo 中调用的构造函数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="keyword">new</span> String[] &#123;configLocation&#125;, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line"><span class="comment">//根据提供的路径，处理成配置文件数组</span></span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line"><span class="comment">// IoC 核心方法</span></span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassPathXmlApplicationContext</code> 类代码比较简单,只包括两个方法 <code>setConfigLocations</code> 与 <code>refresh</code>，这两个方法在该类中都没有实现。</p><h3 id="setConfigLocations"><a href="#setConfigLocations" class="headerlink" title="setConfigLocations"></a>setConfigLocations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(@Nullable String... locations)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (locations != <span class="keyword">null</span>) &#123;</span><br><span class="line">Assert.noNullElements(locations, <span class="string">"Config locations must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">new</span> String[locations.length];</span><br><span class="line">     <span class="comment">// 根据传入的路径解析成配置文件数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; locations.length; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations[i] = resolvePath(locations[i]).trim();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.configLocations = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolvePath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getEnvironment"><a href="#getEnvironment" class="headerlink" title="getEnvironment"></a>getEnvironment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConfigurableEnvironment <span class="title">getEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.environment == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = createEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.environment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取环境变量。如果为空则调用方法新建。</p><h4 id="createEnvironment"><a href="#createEnvironment" class="headerlink" title="createEnvironment"></a>createEnvironment</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableEnvironment <span class="title">createEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回了一个 <code>StandardEnvironment</code> 类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEnvironment</span> <span class="keyword">extends</span> <span class="title">AbstractEnvironment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统环境变量名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JVM 变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据系统环境变量与 JVM 变量设置资源列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizePropertySources</span><span class="params">(MutablePropertySources propertySources)</span> </span>&#123;</span><br><span class="line">        propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME,</span><br><span class="line">                        getSystemProperties()));</span><br><span class="line">        propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,</span><br><span class="line">                        getSystemEnvironment()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>customizePropertySources</code> 方法会往资源列表中添加 Java 进程中的变量和系统的环境变量。</p><h4 id="resolveRequiredPlaceholders"><a href="#resolveRequiredPlaceholders" class="headerlink" title="resolveRequiredPlaceholders"></a>resolveRequiredPlaceholders</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * org.springframework.core.env.AbstractPropertyResolver#resolveRequiredPlaceholders</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.strictHelper == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.strictHelper = createPlaceholderHelper(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.strictHelper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * org.springframework.core.env.AbstractPropertyResolver#doResolvePlaceholders</span></span><br><span class="line"><span class="comment"> * 方法引用，调用 placeholderResolver.resolvePlaceholder(String) 时，</span></span><br><span class="line"><span class="comment"> * 会调用 PropertySourcesPropertyResolver#getPropertyAsRawString(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">this</span>::getPropertyAsRawString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * org.springframework.util.PropertyPlaceholderHelper#replacePlaceholders</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line"><span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolveRequiredPlaceholders</code> 方法处理流程比较长，最后进入到 <code>PropertyPlaceholderHelper</code> 类 <code>parseStringValue</code> 方法来替换占位符。</p><p><strong>这里我们传入的 value 是路径，并没有占位符，所以不会进入到替换占位符的过程中，所以这里暂时不分析 <code>parseStringValue</code>方法</strong>。</p><blockquote><p>到这里 <code>setConfigLocations</code> 方法流程就结束了，最后将路径放入到存放配置文件路径的字符串数组 <code>configLocations</code> 中。</p></blockquote><h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><p><code>refresh</code> 方法是容器初始化的过程，涵盖流程非常多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 保证该方法不会被同时访问，否则会出现在启动时同时销毁了原容器的现象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 准备工作，记录容器的启动时间，标记”已启动“ 状态、处理配置文件中的占位符</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将配置文件解析为 BeanDefinition 注册到 BeanFactory 中，但是没有初始化 Bean</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载器，添加 BeanPostProcessor，注册特殊 Bean</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为容器的某些子类指定特殊的 BeanPost 事件处理器</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 实现类</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 MessageSource，与国际化相关</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模板方法，初始化特殊 Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有非懒加载的 singleton bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 销毁已创建的单例 Bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消 refresh 操作，重置容器的同步标识</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用 <code>synchronized</code> 关键字将方法体包裹，避免在<code>refresh</code> 方法未执行完毕时，被其他线程发起启动或销毁容器的操作所干扰。</p><h4 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h4><p>容器启动准备工作，包括记录容器启动的时间、设置容器状态为已启动、检查环境变量等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录启动时间，设置容器状态为已激活</span></span><br><span class="line">    <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化占位符属性源。该类中没有实现该方法，可以根据需要自行扩展实现</span></span><br><span class="line">    initPropertySources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验必要属性是否为空，主要是环境变量中配置的值（包括系统环境变量与进程环境变量）</span></span><br><span class="line">    getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储 refresh 前的应用监听器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationListeners = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="keyword">this</span>.applicationListeners);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.clear();</span><br><span class="line">        <span class="keyword">this</span>.applicationListeners.addAll(<span class="keyword">this</span>.earlyApplicationListeners);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="validateRequiredProperties"><a href="#validateRequiredProperties" class="headerlink" title="validateRequiredProperties"></a>validateRequiredProperties</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.propertyResolver.validateRequiredProperties();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MissingRequiredPropertiesException ex = <span class="keyword">new</span> MissingRequiredPropertiesException();</span><br><span class="line"><span class="keyword">for</span> (String key : <span class="keyword">this</span>.requiredProperties) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getProperty(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">ex.addMissingRequiredProperty(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验设置为必要属性的字段对应的值是否为空，为空直接抛出异常。</p><blockquote><p>如果项目存在启动必须依赖的变量，我们可以在环境变量中添加 key 与 value，并且调用 <code>org.springframework.core.env.ConfigurablePropertyResolver#setRequiredProperties</code> 方法设置变量对应的值必须不为空。</p><p>我们可以自定义一个 <code>AbstractApplicationContext</code> 的子类，并重写上面提到的 <code>initPropertySources</code> 方法，将字段加入校验集合中。</p></blockquote><h4 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h4><p>该方法负责 BeanFactory 的初始化、BeanDefinition 的加载和注册等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭旧的 BeanFactory，创建新的 BeanFactory，加载并注册 BeanDefinition。抽象方法，交由子类实现</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 获取上一步中创建的 BeanFactory。抽象方法，交由子类实现</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>obtainFreshBeanFactory</code> 方法中调用的两个方法都是抽象方法，交由子类实现，这是典型的模板方法模式。</p></blockquote><h5 id="refreshBeanFactory"><a href="#refreshBeanFactory" class="headerlink" title="refreshBeanFactory"></a>refreshBeanFactory</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 ApplicationContext 中已经加载过 BeanFactory，则销毁所有 Bean 并且关闭 BeanFactory</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 DefaultListableBeanFactory</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖，是否允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 抽象方法，加载 BeanDefinition 到 BeanFactory 中</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                <span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法创建了一个 <code>DefaultListableBeanFactory</code>，其类结构图如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-04-23-193208.png" alt="DefaultListableBeanFactory" title="">                </div>                <div class="image-caption">DefaultListableBeanFactory</div>            </figure><p>可以看到这个类继承了所有关于容器的接口与抽象类。</p><h5 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否允许 BeanDefinition 覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否允许 Bean 循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">        beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法用于设置刚刚创建的 BeanFactory 的两个属性：是否允许 BeanDefinition 覆盖，是否允许 Bean 循环引用。</p><hr><p> 再进行下一步之前，需要先观看关于<a href="#beandefinition">BeanDefinition</a> 的简介，了解 <code>BeanFactory</code> 中存放的究竟是什么，才能更好的理解接下来的内容。</p><hr><h5 id="loadBeanDefinitions"><a href="#loadBeanDefinitions" class="headerlink" title="loadBeanDefinitions"></a>loadBeanDefinitions</h5><p>该方法也是十分重要的方法，它通过 XML 加载 <code>BeanDefinition</code>，存放至刚刚创建的 <code>BeanFactory</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 为 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    <span class="comment">// 注意此处，XmlBeanDefinitionReader 将当前类设置为了 ResourceLoader</span></span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 BeanDefinitionReader，默认实现里面仅开启了 XML 校验</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 beanDefinitionReader 加载 BeanDefinition</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从 resource 中加载 beanDefinition</span></span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据配置文件路径加载 BeanDefinition（也会先根据路径获取对应的 Resource）</span></span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造了一个 <code>BeanDefinitionReader</code> 用于读取配置文件中的 BeanDefinition，注意此处，XmlBeanDefinitionReader 将当前类设置为了 ResourceLoader，用于将配置文件转换为 Spring 中的 Resource 对象。</p><p>第二个方法中，首先尝试从 configResource 中加载 BeanDefinition，这个值可以在构造 ClassPathXmlApplicationContext 时传入，不过一般不会使用，且 <code>AbstractXmlApplicationContext#getConfigResources</code>  默认返回空值。</p><p>之后就是从我们传入的配置文件路径 <code>classpath:applicationfile.xml</code> 加载 BeanDefinition。</p><p>下面贴出根据配置文件路径加载 BeanDefinition 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(locations, <span class="string">"Location array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (String location : locations) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(location);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回加载的 BeanDefinition 的数量</span></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(location, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location, @Nullable Set&lt;Resource&gt; actualResources)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 在实例化 XmlBeanDefinitionReader 后，IoC 容器将自己注入该读取器作为 resourceLoader</span></span><br><span class="line">    ResourceLoader resourceLoader = getResourceLoader();</span><br><span class="line">    <span class="keyword">if</span> (resourceLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Cannot import bean definitions from location ["</span> + location</span><br><span class="line">                        + <span class="string">"]: no ResourceLoader available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceLoader <span class="keyword">instanceof</span> ResourcePatternResolver) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将配置文件转换为 Resource 对象</span></span><br><span class="line">            Resource[] resources = ((ResourcePatternResolver) resourceLoader)</span><br><span class="line">                    .getResources(location);</span><br><span class="line">            <span class="comment">// 委派调用其子类 XmlBeanDefinitionReader 的方法，实现加载功能</span></span><br><span class="line">            <span class="keyword">int</span> loadCount = loadBeanDefinitions(resources);</span><br><span class="line">            <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">                    actualResources.add(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location pattern ["</span></span><br><span class="line">                        + location + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> loadCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                    <span class="string">"Could not resolve bean definition resource pattern ["</span> + location + <span class="string">"]"</span>,</span><br><span class="line">                    ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将指定位置的资源文件解析为 Resource，至此完成了对 BeanDefinition 的资源定位</span></span><br><span class="line">        Resource resource = resourceLoader.getResource(location);</span><br><span class="line">        <span class="comment">// 从 resource 中加载 BeanDefinition，loadCount 表示加载的 BeanDefinition 的个数</span></span><br><span class="line">        <span class="keyword">int</span> loadCount = loadBeanDefinitions(resource);</span><br><span class="line">        <span class="keyword">if</span> (actualResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">            actualResources.add(resource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Loaded "</span> + loadCount + <span class="string">" bean definitions from location ["</span> + location</span><br><span class="line">                    + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> loadCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">    <span class="comment">// 加载的 BeanDefinition 总数</span></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">        counter += loadBeanDefinitions(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面由子类 <code>XmlBeanDefinitionReader</code> 对资源文件进行加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"Detected cyclic loading of "</span> + encodedResource</span><br><span class="line">                        + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">            <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 真正的加载</span></span><br><span class="line">            <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        currentResources.remove(encodedResource);</span><br><span class="line">        <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，到此时，还没有实际加载配置文件，而该方法中调用了 <code>doLoadBeanDefinitions</code> ，Spring 中方法命名用 <code>do</code>  开头的才是实际进行操作的方法。</p><h5 id="doLoadBeanDefinitions"><a href="#doLoadBeanDefinitions" class="headerlink" title="doLoadBeanDefinitions"></a>doLoadBeanDefinitions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 XML 文件转化为 Document 对象</span></span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 根据 Document 对象注册 BeanDefinition</span></span><br><span class="line">        <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource</span><br><span class="line">                        + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法分为两步：将 XML 文件转化为 Document 对象，根据 Document 对象注册 BeanDefinition。文件转换为 Document 对象不是重点，这里略过。</p><h5 id="registerBeanDefinitions"><a href="#registerBeanDefinitions" class="headerlink" title="registerBeanDefinitions"></a>registerBeanDefinitions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="comment">// 获取已注册的 BeanDefinition 数量</span></span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 加载 Document 对象中的 BeanDefinition</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="comment">// 获取本次注册的 BeanDefinition 数量</span></span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">    <span class="comment">// 获取根节点，从根节点开始加载</span></span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="doRegisterBeanDefinitions"><a href="#doRegisterBeanDefinitions" class="headerlink" title="doRegisterBeanDefinitions"></a>doRegisterBeanDefinitions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根节点</span></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是默认 namespace（http://www.springframework.org/schema/beans）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="comment">// 解析配置文件中的 profile 属性，&lt;beans ... profile="***" /&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span></span><br><span class="line">                            + profileSpec +</span><br><span class="line">                            <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置扩展</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析 XML，转换 BeanDefinition</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 后置扩展</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>preProcessXml</code> 与 <code>postProcessXml</code> 方法是 <code>DefaultBeanDefinitionDocumentReader</code> 留给我们自定义实现的在注册 BeanDefinition 前后的处理逻辑。</p><h5 id="parseBeanDefinitions"><a href="#parseBeanDefinitions" class="headerlink" title="parseBeanDefinitions"></a>parseBeanDefinitions</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default namespace 包括四个标签：&lt;import/&gt;、&lt;alias/&gt;、&lt;beans/&gt; 和 &lt;bean/&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 解析 default namespace 下面的元素</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 解析其它 namespace 元素</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下我们项目配置文件都是配置的 default namespace，所以进入 <code>parseDefaultElement</code> 。</p><h5 id="parseDefaultElement"><a href="#parseDefaultElement" class="headerlink" title="parseDefaultElement"></a>parseDefaultElement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// import 标签处理</span></span><br><span class="line">    <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">        importBeanDefinitionResource(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// alias 标签处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">        processAliasRegistration(ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bean 标签处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">        processBeanDefinition(ele, delegate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// beans 标签递归处理</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">        doRegisterBeanDefinitions(ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只分析注册 BeanDefinition 的过程，所以进入 bean 标签处理方法 <code>processBeanDefinition</code>。</p><h5 id="processBeanDefinition"><a href="#processBeanDefinition" class="headerlink" title="processBeanDefinition"></a>processBeanDefinition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取 bean 节点中的信息，封装到 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析 &lt;bean/&gt; 节点自定义属性与自定义子节点，设置 BeanDefinition</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanDefinitionReaderUtils</span><br><span class="line">                    .registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步从 bean 节点中提取 BeanDefinitionHolder，BeanDefinitionHolder 包括 BeanDefinition，beanName 和 aliases，其中 beanName 多数情况下为 id，如果没有指定 id 则为别名集合中的第一个别名。</p><h5 id="parseBeanDefinitionElement"><a href="#parseBeanDefinitionElement" class="headerlink" title="parseBeanDefinitionElement"></a>parseBeanDefinitionElement</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String beanName = id;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 如果没有指定 id，则设置为别名列表中的第一个别名</span></span><br><span class="line">beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line"><span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 &lt;bean/&gt; 节点创建 BeanDefinition，然后将配置信息设置到实例中。经过该行，BeanDefinition 就创建完成</span></span><br><span class="line">AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line"><span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line"><span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">!<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">aliases.add(beanClassName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line"><span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">error(ex.getMessage(), ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面进入单独创建 BeanDefinition 的方法 <code>parseBeanDefinitionElement</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">Element ele, String beanName, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">String className = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">&#125;</span><br><span class="line">String parent = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 创建 BeanDefinition，然后设置类信息</span></span><br><span class="line">AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 BeanDefinition 的属性</span></span><br><span class="line">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析 &lt;bean/&gt; 节点中的子节点</span></span><br><span class="line">parseMetaElements(ele, bd);</span><br><span class="line">parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">parseConstructorArgElements(ele, bd);</span><br><span class="line">parsePropertyElements(ele, bd);</span><br><span class="line">parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.parseState.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入创建 BeanDefinition 的方法 <code>createBeanDefinition</code>。</p><h5 id="createBeanDefinition"><a href="#createBeanDefinition" class="headerlink" title="createBeanDefinition"></a>createBeanDefinition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(@Nullable String className, @Nullable String parentName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> BeanDefinitionReaderUtils.createBeanDefinition(</span><br><span class="line">parentName, className, <span class="keyword">this</span>.readerContext.getBeanClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractBeanDefinition <span class="title">createBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">GenericBeanDefinition bd = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">bd.setParentName(parentName);</span><br><span class="line"><span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">bd.setBeanClass(ClassUtils.forName(className, classLoader));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">bd.setBeanClassName(className);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bd;</span><br></pre></td></tr></table></figure><p>第二个方法就是实际创建 BeanDefinition 的方法，这里设置了 BeanDefinition 的一些基本信息，返回给上面的方法，之后根据配置对 BeanDefinition 属性进行补充。</p><hr><p>到这里为止，终于根据配置文件 <bean/> 节点获取到了 BeanDefinition。</p><hr><p>下面分析注册 BeanDefinition 的过程。</p><p>回到创建完 BeanDefinition 之后的处理逻辑中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提取 bean 节点中的信息，封装到 BeanDefinitionHolder 中</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析 &lt;bean/&gt; 节点自定义属性与自定义子节点，设置 BeanDefinition</span></span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanDefinitionReaderUtils</span><br><span class="line">                    .registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <code>registerBeanDefinition</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">String beanName = definitionHolder.getBeanName();</span><br><span class="line"><span class="comment">// 根据 beanName 注册 BeanDefinition</span></span><br><span class="line">registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 aliases 注册 BeanDefinition</span></span><br><span class="line">String[] aliases = definitionHolder.getAliases();</span><br><span class="line"><span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">registry.registerAlias(beanName, alias);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们最开始创建的 BeanFactory 类型是 <code>DefaultListableBeanFactory</code>，所以进入<code>DefaultListableBeanFactory#registerBeanDefinition</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                    beanName,</span><br><span class="line">                    <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 beanName 查看之前是否注册过相同 beanName 的 BeanDefinition</span></span><br><span class="line">    BeanDefinition existingDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否允许覆盖，在创建 DefaultListableBeanFactory 时设置，默认允许覆盖</span></span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(),</span><br><span class="line">                    beanName,</span><br><span class="line">                    <span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span></span><br><span class="line">                            + beanName +</span><br><span class="line">                            <span class="string">"': There is already ["</span> + existingDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (existingDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// 框架定义的 BeanDefinition 可以直接覆盖用户自定义的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                        existingDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(existingDefinition)) &#123;</span><br><span class="line">            <span class="comment">// 新的 BeanDefinition 覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a different definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// beanDefinition.equals(existingDefinition)</span></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with an equivalent definition: replacing ["</span> + existingDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 覆盖</span></span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有相同 beanName 的 BeanDefinition，进入该分支</span></span><br><span class="line">        <span class="comment">// 判断是否有其他 Bean 已经开始初始化。</span></span><br><span class="line">        <span class="comment">// 注意，注册 BeanDefinition 后 Bean 没有被初始化，在 Spring 容器启动的最后，Spring 会根据 BeanDefinition 预初始化所有单例 Bean</span></span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// 进入此处，说明容器已经至少在 Bean 创建阶段了。这个时候需要获取锁来保证操作的安全。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">                        <span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(</span><br><span class="line">                            <span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将 BeanDefinition 放入 BeanDefinitionMap 中，该 Map 保存了所有的 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="comment">// 将 beanName 放入 beanDefinitionNames 中，该 List 保存了所有 BeanDefinition 的名字</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="comment">// 从手动注册的单例 Bean 集合中移除该 BeanDefinition</span></span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (existingDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很长，但是很多是为了日志打印，其中的重点是保存 BeanDefinition 相关信息的集合</p><p><code>beanDefinitionMap</code> 会保存所有注册的 BeanDefinition，<code>beanDefinitionNames</code> 则会放入所有注册的 BeanDefinition 的 beanName。</p><hr><p>到这里为止 BeanDefinition 已经注册到容器中</p><hr><p>之后应该回到 <code>org.springframework.context.support.AbstractApplicationContext#obtainFreshBeanFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭旧的 BeanFactory，创建新的 BeanFactory，加载并注册 BeanDefinition。抽象方法，交由子类实现</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 获取上一步中创建的 BeanFactory。抽象方法，交由子类实现</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册 BeanDefinition 之后，refreshBeanFactory 方法就执行完毕，之后将新的 BeanFactory 返回至 refresh 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="comment">// 保证该方法不会被同时访问，否则会出现在启动时同时销毁了原容器的现象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// 准备工作，记录容器的启动时间，标记”已启动“ 状态、处理配置文件中的占位符</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将配置文件解析为 BeanDefinition 注册到 BeanFactory 中，但是没有初始化 Bean</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 BeanFactory 的类加载器，添加 BeanPostProcessor，注册特殊 Bean</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 为容器的某些子类指定特殊的 BeanPost 事件处理器</span></span><br><span class="line">            postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory 方法</span></span><br><span class="line">            invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册 BeanPostProcessor 实现类</span></span><br><span class="line">            registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化 MessageSource，与国际化相关</span></span><br><span class="line">            initMessageSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化当前 ApplicationContext 的事件广播器</span></span><br><span class="line">            initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 模板方法，初始化特殊 Bean</span></span><br><span class="line">            onRefresh();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口</span></span><br><span class="line">            registerListeners();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化所有非懒加载的 singleton bean</span></span><br><span class="line">            finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化容器的生命周期事件处理器，并发布容器的生命周期事件</span></span><br><span class="line">            finishRefresh();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                        <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 销毁已创建的单例 Bean</span></span><br><span class="line">            destroyBeans();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取消 refresh 操作，重置容器的同步标识</span></span><br><span class="line">            cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            resetCommonCaches();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行完第二步 <code>obtainFreshBeanFactory</code>，下面进入第三步 <code>prepareBeanFactory</code>。</p><h4 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h4><p>对容器进行一些设置，例如类加载器、事件处理器等，以及注册一些特殊的 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置 BeanFactory 的类加载器为加载当前 ApplicationContext 的加载器，用于加载 BeanFactory 中注册的 BeanDefinition</span></span><br><span class="line">    beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    beanFactory.setBeanExpressionResolver(</span><br><span class="line">            <span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个 BeanPostProcessor，用于回调实现了 Aware 接口的 beans</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果某些 Bean 依赖于以下几个接口的实现类，在自动装配时会忽略它们，Spring 会通过其它方式处理依赖</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为特殊 Bean 赋值，如果其它 Bean 依赖了以下的类，会注入这里的值。</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">    beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册事件监听器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// loadTimeWeaver 是 AspectJ 的概念</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(</span><br><span class="line">                <span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果没有 environment、systemProperties、systemEnvironment 这些 Bean，Spring 会自己注册</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME,</span><br><span class="line">                getEnvironment().getSystemProperties());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME,</span><br><span class="line">                getEnvironment().getSystemEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>在 Java 中， <code>java.lang.Class</code> 类来描述其它的类，可以依靠该类创建一个类的实例。</p><p>而在 Spring 中，它使用 <code>BeanDefinition</code> 来描述 <code>Bean</code>， <code>BeanFactory</code>  中存储的实际上是 <code>BeanDefinition</code>，而不是直接存储实例。当我们项目中需要某个单例类时，Spring 会检索容器中是否已经存在创建好的该类的实例，如果没有则依据 <code>BeanFactory</code> 中该类的 <code>BeanDefinition</code> 来创建一个实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 的作用域，默认只提供 singleton 和 prototype 两种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">    String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置父 Bean，继承父 Bean 的配置信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(@Nullable String parentName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取父 Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Bean 的类名称，之后通过反射来生成实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(@Nullable String beanClassName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Bean 的类名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 bean 的作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(@Nullable String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 bean 作用域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置是否懒加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否懒加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Bean 的依赖（对应 depends-on= 设置的值）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(@Nullable String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回该 Bean 的所有依赖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置 Bean 是否可以注入到其它 Bean 中，只对根据类型注入有效</span></span><br><span class="line"><span class="comment">     * 如果根据名称注入，即使这里设置为 false 也能够注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 是否可以注入到其它 Bean 中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当同一个接口有多个实现时，如果不指定名称，Spring 会优先选择 primary 为 true 的 bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是 primary bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果该 Bean 采用工厂方法生成，指定工厂名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setFactoryMethodName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(@Nullable String factoryBeanName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取工厂名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定工厂类中的工厂方法名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setFactoryBeanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #setBeanClassName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(@Nullable String factoryMethodName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取工程类中的工厂方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取构造器参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the ConstructorArgumentValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该 Bean 的构造器是否带参数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasConstructorArgumentValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !getConstructorArgumentValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 中的属性</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the MutablePropertyValues object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该 Bean 是否有属性值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 5.0.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasPropertyValues</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !getPropertyValues().isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为 singleton</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #SCOPE_SINGLETON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为 prototype</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #SCOPE_PROTOTYPE</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为抽象 Bean，如果是则不能被实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义 BeanDefinition 的资源描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>BeanDefinition</code> 中包含了很多的信息，都是用来描述 Bean 的各种特征。</p><p>Spring 也是基于该类来管理容器中的 Bean。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringIoC 对于 Bean 的管理流程非常长，贴了完整的代码便于跟踪，字符数接近 5w，所以需要拆出来作为上半部分。上半部分主要讲了 refresh 方法中关于从配置文件加载 BeanDefinition 以及注册到 BeanFactory 中的流程，在下半部分中会分析根据 BeanDefinition 创建 Bean 实例的过程。</p><p>本篇中加载及注册 BeanDefinition 几乎全部集中在 <code>refreshBeanFactory</code> 方法中，理解该方法也不容易，我也是跟着各种文章看了三遍左右才能在不看文章的情况下说出整个过程，还是需要跟着 Demo 多 Debug，有些难理解的点看看参数对应的值也许就能懂了。</p><p>这里贴一个简易的<a href="http://naotu.baidu.com/file/88627cd95a7b93d1cb585d28f86823ca?token=3baa4464b1fcfd6a" target="_blank" rel="noopener">流程图</a>，其中绘制了 ClassPathXmlApplicationContext 管理 Bean 的核心流程中的主要方法，没有写明每个方法的作用，用于在弄懂流程之后回顾。如果能根据这些方法名想起其中的过程，也就算是理解了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="http://svip.iocoder.cn/categories/Spring/" target="_blank" rel="noopener">芋道源码</a></p></li><li><p><a href="https://javadoop.com/post/spring-ioc" target="_blank" rel="noopener">Javadoop</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?biz=MzU5MDgzOTYzMw==&mid=2247484561&idx=1&sn=a7281dae7aaaa3499d59dec730464e63&scene=21#wechat_redirect" target="_blank" rel="noopener">Java 学习录</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Ioc&lt;/code&gt; 是 &lt;code&gt;Spring&lt;/code&gt; 中重要的概念，本文以 &lt;code&gt;ClassPathXmlApplicationContext&lt;/code&gt; 为例，结合源代码深入分析 &lt;code&gt;IoC&lt;/code&gt; 容器的实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring,SourceCode" scheme="http://changleamazing.com/categories/Spring-SourceCode/"/>
    
    
      <category term="SourceCode" scheme="http://changleamazing.com/tags/SourceCode/"/>
    
      <category term="Ioc" scheme="http://changleamazing.com/tags/Ioc/"/>
    
      <category term="Spring" scheme="http://changleamazing.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>消息消费</title>
    <link href="http://changleamazing.com/2020/04/20/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    <id>http://changleamazing.com/2020/04/20/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</id>
    <published>2020-04-19T16:45:00.000Z</published>
    <updated>2020-04-20T19:41:09.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="消息拉取"><a href="#消息拉取" class="headerlink" title="消息拉取"></a>消息拉取</h3><p>消息消费一般有两种模式，推模式与拉模式。<br>推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。<strong>Kafka 中的消息消费基于拉模式。</strong></p><p>拉模式主要方法为 <code>poll()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(Duration timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>当有消息待消费时，该方法会立即返回。否则，会等待参数 <code>timeout</code> 指定的时间。<strong>从 Kafka 2.0.0 开始，<code>timeout</code> 类型从 <code>long</code> 变为 JDK8 中新的时间类型 <code>Duration</code>。</strong></p><p>Kafka 的消息消费是不断轮询的过程，消费者会重复调用 <code>poll()</code> 方法，获取所订阅的主题的一组消息。</p><p>消费者消费到的每条消息类型为 <code>ConsumerRecord</code>，与发送者发送的消息类型 <code>ProducerRecord</code> 对应。</p><h3 id="消费位移"><a href="#消费位移" class="headerlink" title="消费位移"></a>消费位移</h3><p>Kafka 的分区中，每条消息都有唯一的 offset。这个 offset 在消费端也存在，用来表示消费到的消息在所在分区中的位置。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-04-20-121854.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong>消费位移对应图中的 position，表示下一条需要拉取的消息的位置。</strong><br>在消费端拉取消息时，返回的是没有被消费过的消费集，这需要记录已经被消费的消息的位移，Kafka 将该位移持久化保存，否则当消费者重启之后就无法知道消费位移。另一种情况是当消费端有新的消费者加入之后，分区与消费者的关系会被重新分配，如果不保存分区的消费位移，新绑定的消费者就无法知道从哪个消息开始消费。</p><p>消费位移的存储从 Zookeeper 中转移到了 Kafka 内部主题 <code>_consumer_offsets</code> 中。</p><h3 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h3><p>将消费位移持久化的动作称为“提交”，消费者在消费完消息之后需要执行消费位移的提交。</p><p>确定位移提交的时机是一个难题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-04-20-175306.jpg" alt="位移提交" title="">                </div>                <div class="image-caption">位移提交</div>            </figure><p>在上图情况下，消费者拉取到了区间 [x+2,x+7] 的消息，并且正在处理 x+5 对应的消息。</p><h4 id="消息处理前提交"><a href="#消息处理前提交" class="headerlink" title="消息处理前提交"></a>消息处理前提交</h4><p>假设在 <code>poll()</code> 方法拉取到消息之后立刻进行位移提交，即消费位移置为 x+8。如果对 x+5 对应消息处理出现异常，在故障恢复之后，重新拉取的消息会从 x+8 开始的，这会导致区间 [x+5,x+7] 的消息未被消费，发生消息丢失的情况。</p><h4 id="消息处理后提交"><a href="#消息处理后提交" class="headerlink" title="消息处理后提交"></a>消息处理后提交</h4><p>假设在 <code>poll()</code> 方法拉取到消息并且将消息处理完毕再提交，如果仍然是处理到 x+5 时发生异常，故障恢复后从 x+2 位置重新开始消费，那么区间 [x+2,x+4] 的消息会被二次消费，发生重复消费的情况。</p><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>Kafka 默认的位移提交方式是自动提交，对应的参数为 <code>enable.auto.commit</code>，值为 true。自动提交的周期由参数 <code>auto.commit.interval.ms</code> 控制，默认值为 5s。</p><p>在默认的方式下，消费者每隔 5s 会将每个分区中最大的消息位移进行提交。提交的动作是在 <code>poll()</code> 方法的逻辑里完成的，在每次真正向服务端发起拉取请求之前会检查是否可以进行位移提交。</p><p>自动提交不需要我们进行额外的处理，但是自动提交也会带来重复消费与消息丢失的问题。<br>当消费一批消息后而在位移提交前消费者崩溃了，那么故障恢复后，这些消息又会被重新消费一次。<br>消息丢失的发生条件会苛刻一些。假设消费者端在拉取到了消息之后，将消息不断地放入本地缓存中，比如 <code>BlockingQueue</code> 中，而另一个线程对 <code>BlockingQueue</code> 中的数据进行处理。此时拉取线程直接返回处理完毕，在下一次拉取时进行位移提交。如果此时 <code>BlockingQueue</code> 中上一次拉取的数据还未被处理，且此时处理线程发生了异常，会导致之前被拉取的消息丢失了。</p><h3 id="控制消费"><a href="#控制消费" class="headerlink" title="控制消费"></a>控制消费</h3><p>在某些应用场景下需要暂停某些分区消费先消费其它分区，之后再恢复该分区的消费。<br>KafkaConsumer 中使用 <code>pause()</code> 与 <code>resume()</code> 方法实现暂停分区消费与恢复分区消费的操作，除此之外，还提供了 <code>paused()</code> 方法返回被暂停消费的分区集合。</p><p>KafkaConsumer 提供了 <code>wakeup()</code> 方法让其他线程安全调用，退出拉取消息的逻辑，抛出 <code>WakeupException</code>。</p><p>当消费端发生异常跳出循环之后，我们必须显示地执行关闭动作来释放占用的资源。KafkaConsumer 提供了 <code>close()</code> 方法来实现资源释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Duration timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>第一种方法调用之后，会等待 Kafka 进行一些需要的清理操作，如果开启了自动提交消费位移，这里还会触发一次提交，虽然方法参数没有设置时间，但是 Kafka 内部默认等待时间为 30s。<br>第二种方式则限制了在指定时间内完成对 Kafka 关闭的收尾工作，如果时间很短，消费者会在没有自动提交消费位移的情况下被强制关闭。<br><strong>wakeup() 方法不应该被用来中断 close() 方法。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;消息拉取&quot;&gt;&lt;a href=&quot;#消息拉取&quot; class=&quot;headerlink&quot; title=&quot;消息拉取&quot;&gt;&lt;/a&gt;消息拉取&lt;/h3&gt;&lt;p&gt;消息消费一般有两种模式，推模式与拉模式。&lt;br&gt;推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://changleamazing.com/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="http://changleamazing.com/2020/04/19/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://changleamazing.com/2020/04/19/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2020-04-18T16:45:00.000Z</published>
    <updated>2020-04-20T19:41:13.285Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 内部都是以字节数组的形式来传播消息的。<br>生产者使用序列化器将对象转换成字节数组，消费者使用反序列化器将字节数组转换成相应的对象。</p><h3 id="序列化接口"><a href="#序列化接口" class="headerlink" title="序列化接口"></a>序列化接口</h3><p>最常使用的是 <code>StringSerializer</code>，Kafka 也提供了对于 <code>ByteArray</code>、<code>ByteBuffer</code>、<code>Bytes</code>、<code>Double</code>、<code>Integer</code>、<code>Long</code> 这几种类型的序列化器，它们都实现了</p><p><code>org.apache.kafka.common.serialization.Serializer</code> 接口。</p><p>该接口有四个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializer</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Configure this class.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> configs configs in key/value pairs</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isKey whether is for key or value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs, <span class="keyword">boolean</span> isKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convert &#123;<span class="doctag">@code</span> data&#125; into a byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic topic associated with data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data typed data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> serialized bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">byte</span>[] serialize(String topic, T data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convert &#123;<span class="doctag">@code</span> data&#125; into a byte array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic topic associated with data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> headers headers associated with the record</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data typed data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> serialized bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">byte</span>[] serialize(String topic, Headers headers, T data) &#123;</span><br><span class="line">        <span class="keyword">return</span> serialize(topic, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Close this serializer.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * This method must be idempotent as it may be called multiple times.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>configure()</code> 方法用来配置当前类，<code>serialize()</code> 方法用来执行序列化操作，<code>close()</code> 方法用来关闭当前的序列化器，一般情况下实现类中都不会重写<code>close()</code> 方法，如果重写该方法，必须确保该方法的幂等性，因为这个方法很可能会被 <code>KafkaProducer</code> 调用多次。</p><h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><p>自定义序列化器非常简单，当 Kafka 提供的序列化器的序列化方法不满足我们的需求时，我们可以通过实现 <code>org.apache.kafka.common.serialization.Serializer</code> 接口，并重写其中的 <code>serialize</code> 方法即可。</p><p>之后只需要定义 KafkaProducer 的序列化配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, CustomSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述都是以生产者序列化器作为例子来说明，反序列化器与序列化器的逻辑及自定义方式一致。如果没有特殊需要，不建议自定义序列化器与反序列化器，这样会增加生产者与消费者的耦合度，升级换代容易出错。如果需要自定义序列化器与反序列化器，那么尽量在序列化方法中使用通用的序列化工具来包装，例如 <code>Thrift</code>、<code>ProtoBuf</code> 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kafka 内部都是以字节数组的形式来传播消息的。&lt;br&gt;生产者使用序列化器将对象转换成字节数组，消费者使用反序列化器将字节数组转换成相应的对象。&lt;/p&gt;
&lt;h3 id=&quot;序列化接口&quot;&gt;&lt;a href=&quot;#序列化接口&quot; class=&quot;headerlink&quot; title=&quot;序
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://changleamazing.com/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>消费组与消费者</title>
    <link href="http://changleamazing.com/2020/04/18/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E7%BB%84/"/>
    <id>http://changleamazing.com/2020/04/18/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E7%BB%84/</id>
    <published>2020-04-17T16:45:00.000Z</published>
    <updated>2020-04-20T19:41:08.257Z</updated>
    
    <content type="html"><![CDATA[<p>消费者负责订阅 Kafka 中的主题，并且从订阅的主题上拉取消息。每个消费者都有一个对应的消费组，当消息发布到主题后，只会被投递给订阅它的消费组中的一个消费者。</p><p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-04-14-162633.jpg" alt="Consumer-Group"></p><p>如上图所示，某个主题中共有 4 个分区。消费组 A 和 B 都订阅了这个主题，消费组 A 中有4个消费者，消费组B中有 2 个消费者。按照 Kafka 默认的规则，最后的分配结果是消费组 A 中的每一个消费者分配到 1 个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。<strong>每个消费者只能消费所分配到的分区中的消息</strong>，<strong>即每一个分区只能被一个消费组中的一个消费者所消费。</strong></p><p>对于需要订阅同一个主题的不同服务来说，需要配置不同的消费组，否则会导致同一个消费组内的不同服务都只能消费到该主题中部分分区的消息，导致数据不完整或者状态错误。</p><p>消费组会根据组内消费者的个数，为每个消费者动态分配消费的主题分区个数。这种模型可以让整体消费能力具备横向伸缩性，可以通过增减消费者的个数来控制整体的消费能力。</p><p>如果出现消费组中消费者个数大于主题分区数的情况，会导致某些消费者分配不到分区而无法消费任何消息。</p><p><code>partition.assignment.strategy</code> 参数用来指定分区分配策略。</p><p>Kafka 支持两种消息投递模式：</p><ul><li><p>点对点模式（P2P）</p><p>点对点基于队列，消息生产者发送消息到队列中，消费者从队列中接收消息。一个队列可以存在多个消费者，但是一条消息只有一个消费者能消费到。</p></li><li><p>发布订阅模式（Pub/Sub）</p><p>发布订阅模式基于中间节点，对于 Kafka 来说即主题，这种模式下发布的消息能被所有订阅了该主题的消费者消费。</p></li></ul><p>当所有的消费者都属于同一个消费组时，每个分区的消息只会被一个消费者处理，这属于点对点模式的应用。</p><p>当同一个主题的消费者不属于同一个消费组时，消息会被广播给所有的消费者，即每条消息会被所有的消费者处理，这属于发布/订阅模式的应用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消费者负责订阅 Kafka 中的主题，并且从订阅的主题上拉取消息。每个消费者都有一个对应的消费组，当消息发布到主题后，只会被投递给订阅它的消费组中的一个消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://changleamazing-1253815386.cos.a
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://changleamazing.com/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>生产者整体架构</title>
    <link href="http://changleamazing.com/2020/04/14/%E7%94%9F%E4%BA%A7%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8E%9F%E7%90%86/"/>
    <id>http://changleamazing.com/2020/04/14/%E7%94%9F%E4%BA%A7%E8%80%85%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8E%9F%E7%90%86/</id>
    <published>2020-04-14T01:11:00.000Z</published>
    <updated>2020-05-10T06:28:43.425Z</updated>
    
    <content type="html"><![CDATA[<p>消息在发往 Kafka 之前，可能需要经历拦截器、序列化器和分区器等一系列的处理，生产者客户端的整体架构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-04-11-220442.jpg" alt="生产者整体架构" title="">                </div>                <div class="image-caption">生产者整体架构</div>            </figure><p>可以看到，在生产者端主要有两个线程协调运行，分别为主线程与 Sender 线程。</p><p>其中主线程的作用是处理 KafkaProducer 创建消息，通过拦截器、序列化器和分区器的作用之后缓存消息到消息累加器（也称为消息收集器）中；而 Sender 线程则负责从消息收集器中获取消息并将其发送到 Kafka 中，其中 InFlightRequests 用来缓存已经被 Sender 线程发送但是还没有收到相应的请求。 </p><h3 id="RecordAccumulator"><a href="#RecordAccumulator" class="headerlink" title="RecordAccumulator"></a>RecordAccumulator</h3><p>RecordAccumulator 是消息收集器，主要用来缓存要被发送至 Kafka 的消息，便于 Sender 线程批量发送，这样可以减少网络传输的资源消耗。RecordAccumulator 缓存的大小通过生产者客户端参数 <code>buffer.memory</code> 配置，默认大小为 <code>32MB</code>。</p><p>当生产者生产消息速度超过 Sender 线程发送至服务器的速度时，会导致消息积压在消息收集器中。当消息收集器缓存空间被填满时，KafkaProducer 调用 sender() 方法会被阻塞，当阻塞时间超过 <code>max.block.ms</code> 指定的时间就会抛出异常，默认为 60 秒。</p><p>RecordAccumulator 内部为每个分区都维护了一个<strong>双端队列</strong>，队列中存放的内容为 <code>ProducerBatch</code>，ProducerBatch 是一个消息批次，可以包含一个或多个 ProducerRecord。主线程中发送过来的消息都会被追加到双端队列中，其中较小的 <code>ProducerRecord</code> 会被拼凑成一个较大的 <code>ProducerBatch</code>。</p><p>消息都是以字节的形式传输的，在发送之前需要创建一块内存区域保存对应的消息。内存频繁创建与释放非常耗资源，在 RecordAccumulator 内部有一个 BufferPool，用来实现 ByteBuffer 的复用。BufferPool 只管理 <code>batch.size</code> 指定大小以下的 ByteBuffer，默认值为 <code>16KB</code>。</p><p>消息发送至 RecordAccumulator 中包括以下几个步骤：</p><ol><li>当一条消息（ProducerRecord）流入 RecordAccumulator 时，会先寻找与消息分区所对应的双端队列（如果没有则新建）</li><li>从这个双端队列的尾部获取一个 ProducerBatch（如果没有则新建）</li><li>查看 ProducerBatch 中是否还可以写入这个 ProducerRecord，如果可以则写入，如果不可以则需要创建一个新的 ProducerBatch</li><li>在新建 ProducerBatch 时评估这条消息的大小是否超过 batch.size 参数的大小，如果不超过，那么就以 batch.size 参数的大小来创建 ProducerBatch，这样在使用完这段内存区域之后，可以通过 BufferPool 的管理来进行复用；如果超过，那么就以评估的大小来创建 ProducerBatch，这段内存区域不会被复用。</li></ol><h3 id="InFlightRequests"><a href="#InFlightRequests" class="headerlink" title="InFlightRequests"></a>InFlightRequests</h3><p>InFlightRequests 用来缓存已经被 Sender 线程发送但是还没有收到响应的请求。 </p><p>在介绍 InFlightRequests 存放的消息类型之前，要说明消息的保存形式的转换。</p><p>在主线程发送消息时，我们关注的是消息发往哪个分区，所以在 RecordAccumulator 中消息的保存形式为 <code>&lt;Partition,Deque&lt;ProducerBatch&gt;&gt;</code>，但是被 Sender 线程处理时，关注的是发送到 broker 集群中的哪个节点，所以消息保存的形式被转为 <code>&lt;Node,List&lt;ProducerBatch&gt;&gt;</code>，之后会被进一步封装成 <code>&lt;Node,Request&gt;</code>，其中 Request 是指 Kafka 的各种协议请求，对于消息发送来说就是 ProduceRequest。</p><p>当 Sender 线程将未收到响应的请求保存至 InFlightRequests 中，InFlightRequests 保存对象的形式是 <code>Map&lt;NodeId,Deque&gt;</code>。InFlightRequests 可以通过配置参数 <code>max.in.flight.requests.per.connection</code> 限制每个连接最多缓存的请求数，默认值为 5。即当某个连接中缓存了五个未响应的请求之后，就不能再向该连接发送更多的请求了，除非之后缓存的请求中收到了回复。</p><p>InFlightRequests 还可以获得 <code>leastLoadedNode</code>，即负载最小的 Node。负载最小是通过比较 Node 在 InFlightRequests 中未确认的请求决定的，未确认的请求越多，则认为负载越大。所以 Kafka 会选择 <code>leastLoadedNode</code> 发送请求，以便于能够尽快发出。</p><p>对于消息发送来说，在 RecordAccumulator 中就已经确定了分区，确定分区之后，要发送的 broker 即为该分区的 leader 副本所在的 broker，所以也就确定了 Node，无法根据 <code>leastLoadedNode</code> 来切换节点。这里 <code>leastLoadedNode</code> 是用来处理元数据请求、消费者组播协议的交互。</p><p>元数据是指 Kafka 集群的元数据，这些元数据具体记录了集群中有哪些主题，这些主题有哪些分区，每个分区的 leader 副本分配在哪个节点上，follower 副本分配在哪些节点上，哪些副本在 AR、ISR 等集合中，集群中有哪些节点，控制器节点又是哪一个等信息。</p><p>客户端可以自己发现 broker 节点的地址，这一过程也属于元数据相关的更新操作。与此同时，分区数量及 leader 副本的分布都会动态地变化，客户端也需要动态地捕捉这些变化。</p><p>而元数据的更新是在客户端内部进行的，对客户端的外部使用者不可见。当需要更新元数据时，会先挑选出 <code>leastLoadedNode</code>，然后向这个 Node 发送 <code>MetadataRequest</code> 请求来获取具体的元数据信息。这个更新操作是由 Sender 线程发起的，在创建完 MetadataRequest 之后同样会存入 InFlightRequests，之后各个 broker 会同步元数据。</p><h2 id="生产者参数"><a href="#生产者参数" class="headerlink" title="生产者参数"></a>生产者参数</h2><h3 id="acks"><a href="#acks" class="headerlink" title="acks"></a>acks</h3><p>指定分区必须有几个副本收到消息生产者才会认为这条消息成功写入。该值设置到消息可靠性和吞吐量之间的权衡。</p><p>acks 有三种类型的<strong>字符串值</strong>：</p><ul><li>acks = 1。这是默认值。即只要分区的 leader 副本成功写入就会收到来自己服务器的成功响应。如果消息已写入 leader 副本，但是在被其它 follower 拉取之前 leader 节点崩溃了，这条消息就丢失掉了。<strong>这是可靠性与吞吐量之间的折中方案。</strong></li><li>acks = 0。生产者发送消息之后不需要等待服务端的响应。消息从发送到写入 Kafka 的过程中出现异常就会丢失。当其它配置相同时，acks 设置为 0 可以达到最大的吞吐量。</li><li>acks = -1 或 acks = all。需要等待 ISR 中的所有副本都成功写入消息之后才能收到服务器的成功响应。其它配置相同时，acks 设置为 -1 可以保证最强的可靠性。但是有可能出现 ISR 集合中只有 leader 副本的情况，这与 acks = 1 情况一致。</li></ul><blockquote><p>Kafka 可以保证分区消息有序，如果生产者按照一定的顺序发送消息，那么这些消息也会顺序的写入分区。</p><p>但是如果 acks 参数为非零值，即必须要有副本确认收到消息，并且 <code>max.in.flight.requests.per.connection</code> 参数（即 InFlightRequests 中缓存的请求数量）配置大于 1，就可能会出现消息错序的情况。</p><p>假设第一批次消息写入失败，而第二批次消息发送成功，生产者就会重新发送第一批次的消息，导致第二批次消息比第一批次消息更早写入分区中，消息发生错序。</p><p>如果需要保证消息顺序时，建议把 <code>max.in.flight.requests.per.connection</code> 配置为 1，而不是配置 acks = 0，这样第一批次消息被缓存在 InFlightRequests 中时，第二批次消息无法发送，直到第一批次消息重试成功或者超过重试次数时才会发送第二批次消息。</p></blockquote><h3 id="max-request-size"><a href="#max-request-size" class="headerlink" title="max.request.size"></a>max.request.size</h3><p>限制生产者客户端能发送的消息的最大值，默认为 <code>1048576B</code>，即 <code>1MB</code>。</p><p>该值与其它配置值有联动关系，一般情况下不改动。比如 broker 的 <code>message.max.bytes</code> 参数，如果  <code>message.max.bytes</code>  配置为 <code>10B</code>，而 <code>max.request.size</code> 配置为 <code>20B</code>。此时发送一条 15B 的消息时，生产者客户端也会收到异常。</p><h3 id="retries"><a href="#retries" class="headerlink" title="retries"></a>retries</h3><p>指定发生异常时生产者重试的次数，默认为 0，即不进行任何重试。</p><h3 id="retry-backoff-ms"><a href="#retry-backoff-ms" class="headerlink" title="retry.backoff.ms"></a>retry.backoff.ms</h3><p>指定两次重试之间的时间间隔，避免无效的频繁重试。</p><h3 id="compression-type"><a href="#compression-type" class="headerlink" title="compression.type"></a>compression.type</h3><p>指定消息的压缩方式，默认值为 none，即不压缩消息。该参数可以配置为 gzip/snappy/lz4。对消息进行压缩可以减少网络传输量，提高整体性能，但是压缩会耗费一定的时间，如果对时间有要求，则不推荐对消息进行压缩。</p><h3 id="connections-max-idle-ms"><a href="#connections-max-idle-ms" class="headerlink" title="connections.max.idle.ms"></a>connections.max.idle.ms</h3><p>指定连接的最大闲置时间，默认为 <code>540000ms</code>，即 9 分钟。</p><h3 id="linger-ms"><a href="#linger-ms" class="headerlink" title="linger.ms"></a>linger.ms</h3><p>指定生产者发送 ProducerBatch 之前等待更多 ProducerRecord 加入 ProducerBatch 的时间，默认值为 0。即客户端会在ProducerBatch 被填满或者等待时间超过 linger.ms 配置值之后发送出去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息在发往 Kafka 之前，可能需要经历拦截器、序列化器和分区器等一系列的处理，生产者客户端的整体架构如下图所示：&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
 
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://changleamazing.com/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>Kafka 基础</title>
    <link href="http://changleamazing.com/2020/04/13/Kafka%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://changleamazing.com/2020/04/13/Kafka%20%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-12T16:45:00.000Z</published>
    <updated>2020-04-20T19:39:58.989Z</updated>
    
    <content type="html"><![CDATA[<p>Kafka 是 LinkedIn 开发的一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统。</p><p>Kafka 主要用三个用途：</p><ul><li>消息系统<br>Kafka 与消息中间件一样具备系统解耦、流量削峰、异步通信等功能。除此之外，Kafka 还提供了<strong>消息顺序性保障</strong>以及<strong>回溯消费</strong>的功能</li><li>存储系统<br>消息持久化到磁盘中，相比于内存存储的系统降低了数据丢失的风险</li><li>流式处理平台<br>Kafka 为流式处理框架提供了可靠的数据来源，还提供了一个完整的流式处理类库</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/20200331184722.png" alt="Kafka 结构" title="">                </div>                <div class="image-caption">Kafka 结构</div>            </figure><p>如上图，Kafka 体系结构主要包括三个部分：</p><ul><li>Producer<br>生产者，消息发送方</li><li>Consumer<br>消费者，消息接收方</li><li>Broker<br>服务代理节点。</li></ul><p>Kafka 中还有两个特别重要的概念：主题（Topic）与 分区（Partition）。<br>Kafka 中的消息以 Topic 为单元进行归类，Producer 将消息发送到指定的 Topic，Consumer 则订阅 Topic 消费在该单元上的消息。</p><p>主题是逻辑概念，一个主题可以细分为多个分区，每个分区包含的消息是不同的，分区在存储层面相当于<strong>可追加的日志文件</strong>，消息被追加到分区日志文件的时候都会被分配一个特定的偏移量（offset）。<br>offset 是消息在分区中的唯一标识，Kafka 用它来保证消息在<strong>分区</strong>中的顺序性(Kafka 保证分区有序而非主题有序）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/20200404150034.png" alt="主题中的分区" title="">                </div>                <div class="image-caption">主题中的分区</div>            </figure><p>如上图所示，假设主题中有四个分区，消息被顺序追加到分区日志文件尾部，offset 从 0 开始。一个主题中的分区可以分布在不同的 broker 上。</p><p>Kafka 为分区引入了多副本（Replica）机制，通过增加副本数量可以提升容灾能力。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/20200404154135.png" alt="多副本机制" title="">                </div>                <div class="image-caption">多副本机制</div>            </figure><p>副本之间的关系是一主多从，其中 leader 副本负责处理读写请求，follower 副本只负责与 leader 副本同步消息，follower 副本中的消息与 leader 副本数据同步存在一定延迟。Kafka 通过算法来实现副本在 broker 上均匀分布，所以当 Kafka 集群中某个 broker 失效时，如果该 broker 中存在某分区的 leader 副本时，多副本机制能从该分区分布在其它 broker 上的 follower 副本中选举出新的 leader 副本，实现了故障的自动转移。</p><p>Kafka 消费端也具备一定的容灾能力。Consumer 使用拉模式从服务获取消息，并且会保存消费的具体位置。消费者在宕机后恢复上线时，可以根据之前保存的位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。</p><p>分区中所有副本集合称为 AR（Assigned Replicas），所有与 leader 副本保持一定程度同步的副本（包括 leader 副本）集合称为 ISR（In-Sync Replicas），这里的一定程度是指可忍受的同步滞后范围，通过参数可以配置。同步滞后过多的部分组成 OSR（Out-of-Sync Replicas）。<br><strong>ASR = ISR + OSR。</strong><br>正常情况下，所有 follower 副本都应该与 leader 副本保持一定程序的同步，此时 AR = ISR，OSR 集合为空。<br>ISR 与 OSR 集合中的副本状态可能会发生变化，当 ISR 集合中副本滞后太多时，会被转移到 OSR 集合中。当 OSR 集合中副本在可忍受的滞后时间内又同步到了 leader 副本最新状态，它就会被转移到 ISR 集合中。<br><strong>默认情况下，若 leader 副本发生故障时，ISR 集合中副本才有资格被选举为新的 leader。</strong></p><p>ISR 与 HW（High Watermark） 和 LEO（Log End Offset） 也有关系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/20200404162057.png" alt="HW 和 LEO" title="">                </div>                <div class="image-caption">HW 和 LEO</div>            </figure><p>LEO 标识当前日志文件中下一条待写入消息的 offset。ISR 集合中每个副本都会维护自身的 LEO，而这些副本中最小的 LEO 即为分区的 HW，消费者只能消费 HW 之前的消息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kafka 是 LinkedIn 开发的一个多分区、多副本且基于 ZooKeeper 协调的分布式消息系统。&lt;/p&gt;
&lt;p&gt;Kafka 主要用三个用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消息系统&lt;br&gt;Kafka 与消息中间件一样具备系统解耦、流量削峰、异步通信等功能。除此之外，
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://changleamazing.com/tags/Kafka/"/>
    
      <category term="Message Queue" scheme="http://changleamazing.com/tags/Message-Queue/"/>
    
  </entry>
  
  <entry>
    <title>百度分布式 ID 生成器</title>
    <link href="http://changleamazing.com/2020/02/03/%E5%88%86%E5%B8%83%E5%BC%8F%20id%20%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>http://changleamazing.com/2020/02/03/%E5%88%86%E5%B8%83%E5%BC%8F%20id%20%E7%94%9F%E6%88%90%E5%99%A8/</id>
    <published>2020-02-03T02:18:47.000Z</published>
    <updated>2020-04-20T19:40:32.587Z</updated>
    
    <content type="html"><![CDATA[<p>分布式 ID 生成器是分布式项目开发中的常用工具，弄懂其原理对理解分布式有一定的帮助。</p><a id="more"></a><p>绝大多数公司使用的分布式 ID 生成器都是依赖于雪花算法（<code>snowflake）</code>实现的。</p><h2 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-03-045141.jpg" alt="snowflake" title="">                </div>                <div class="image-caption">snowflake</div>            </figure><p>如上图所示，雪花算法生成 id 为 64 位二进制串，由几个部分组成：</p><ol><li>1 位标识位，默认为 0，因为二进制首位为符号位，一般生成的 id 都要求是正数，所以固定为 0</li><li>41 位时间戳，可以表示的时间为 69 年</li><li>10 位工作机器 id，记录工作机器 id。可以部署在 $2^{10}$ (1024) 个节点上，包括 5 位 datacenterId 和 5 位 workerId</li><li>12 位自增序列。记录同一时间戳内产生的不同 id，支持的序号为$2^{12}$（4096）个</li></ol><p>这样的设计可以保证所有生成的 id 按照时间趋势递增，并且不会产生重复的 id，也可以根据实际节点数扩展或缩减工作机器 id 部分的位数。</p><p>雪花算法的主要缺点是时钟回拨问题。</p><blockquote><p>时钟回拨是指服务器时间因为某些原因导致时间回退。可能导致时钟回拨的原因有多种，比如服务器使用了本地时间，然后服务器校时服务修正了系统时间。</p></blockquote><p>这样会导致生成一个已经使用过的 ID。</p><h2 id="百度-UidGenerator"><a href="#百度-UidGenerator" class="headerlink" title="百度 UidGenerator"></a>百度 UidGenerator</h2><p>百度的 <code>UidGenerator</code> 也是基于 <code>snowflake</code> 来实现的，不过调整了生成的 id 中的组成部分顺序。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-03-112957.jpg" alt="UIDGenerator" title="">                </div>                <div class="image-caption">UIDGenerator</div>            </figure><p>如上图所示，<code>UidGenerator</code> 生成的 64 位二进制串主要包括以下几个部分：</p><ol><li>sign：1 位，与 snowflake 一致，固定为 1，即生成的 UID 为正数</li><li>delta seconds：28 位，时间戳，相对于时间基点 <code>2016-05-20</code> 的增量值，单位：秒，最多可支持约 8.7 年</li><li>worker id：22位，机器 id，每次机器启动（包括重启）时由数据库（<code>MySQL</code> 内置 <code>WorkerID</code> 分配器）分配（也可以自定义实现）。</li><li>sequence：13位，同一个时间戳的并发序列，可以支持$2^{13}$ (8192) 个并发。</li></ol><p> <code>UidGenerator</code> 有两种实现方式：<code>DefaultUidGenerator</code>  和 <code>CachedUidGenerator</code>。</p><h3 id="DefaultUIDGenerator"><a href="#DefaultUIDGenerator" class="headerlink" title="DefaultUIDGenerator"></a>DefaultUIDGenerator</h3><h4 id="delta-seconds"><a href="#delta-seconds" class="headerlink" title="delta seconds"></a>delta seconds</h4><p>这个值是当前时间与 <code>epoch</code>时间的时间差，单位为秒。<code>epoch</code> 时间默认为 <code>2016-09-20</code>，需要将它配置为生成分布式 ID 服务上线的时间。</p><h4 id="worker-id"><a href="#worker-id" class="headerlink" title="worker id"></a>worker id</h4><p>worker id 是在机器启动时通过 MySQL 的内置 WorkerID 分配器分配的。UidGenerator 会在生成分布式 ID 的实例启动的时候，向数据库的表中插入一行数据，数据的 ID 值就是 workerId 的值。由于 workerId 默认为 22 位，所以所有实例重启次数不超过 $2^{22} - 1$ 次。</p><h4 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h4><p>生成 sequence 部分的代码通过 <code>synchronized</code> 关键字保证线程安全，通过简单的异常处理来避免时钟回拨问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentSecond = getCurrentSecond();</span><br><span class="line">    <span class="keyword">if</span> (currentSecond &lt; lastSecond) &#123;</span><br><span class="line">        <span class="keyword">long</span> refusedSeconds = lastSecond - currentSecond;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UidGenerateException(<span class="string">"Clock moved backwards. Refusing for %d seconds"</span>, refusedSeconds);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentSecond == lastSecond) &#123;</span><br><span class="line">        sequence = (sequence + <span class="number">1</span>) &amp; bitsAllocator.getMaxSequence();</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">            currentSecond = getNextSecond(lastSecond);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sequence = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lastSecond = currentSecond;</span><br><span class="line">    <span class="keyword">return</span> bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前时间与上一次生成 id 时间为同一个时间戳，则增加 <code>sequence</code>。如果 <code>sequence</code> 自增值超过 $，就会通过自旋等待下一秒，而不是直接抛出异常。</p><p>如果当前时间是新的一秒，那么将 <code>sequence</code> 置为 0，重新开始分配该秒对应的 id。</p><h3 id="CachedUIDGenerator"><a href="#CachedUIDGenerator" class="headerlink" title="CachedUIDGenerator"></a>CachedUIDGenerator</h3><p><code>CachedUidGenerator</code> 是 <code>UidGenerator</code> 的重要改进实现。它利用了 <code>RingBuffer</code>（与 <a href="https://github.com/LMAX-Exchange/disruptor/tree/master" target="_blank" rel="noopener">disruptor</a> 一致)。</p><h4 id="RingBuffer"><a href="#RingBuffer" class="headerlink" title="RingBuffer"></a>RingBuffer</h4><p><code>RingBuffer</code> 本质上是一个数组，数组中的每个项被称为 <code>slot</code>。<br><code>CachedUidGenerator</code> 设计了两个 <code>RingBuffer</code>，一个用来保存唯一 ID，一个保存 flag。</p><img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-06-023533.jpg" alt="Uid-Genrator RingBuffer" style="zoom:67%;" /><p>每个 <code>RingBuffer</code> 容量为 <code>SnowFlake</code> 算法中 <code>sequence</code> 部分最大值，且为 $2^{n}$，对于 <code>UidGenerator</code> 默认设计来说，即为 $2^{13}$。</p><p><code>UID-RingBuffer</code> 中 <code>Tail</code> 与 <code>Cursor</code> 指针用来读写 <code>slot</code>。其中，<code>Tail</code> 指针表示 <code>Producer</code> 生成的最大序号（此序号从 0 开始，持续递增）。<code>Cursor</code> 指针表示 <code>Consumer</code> 消费到的最小序号。</p><p>这两个指针不能超过对方。若 <code>Cursor</code> 指针超过 <code>Tail</code>，则说明消费了还未生产序号，所以当 <code>Cursor</code> 赶上 <code>Tail</code> 时，应该通过 <code>RejectedTakeBufferHandler</code> 指定 <code>TakeRejectPolicy</code>。</p><p>若 <code>Tail</code> 指针超过 <code>Cursor</code> 指针，则说明生产者覆盖了还未消费的 <code>slot</code>。所以当 <code>Tail</code> 赶上 <code>Cursor</code> 时，应该通过 <code>RejectedPutBufferHandler</code> 指定 <code>PutRejectPolicy</code>。</p><p><code>Flag-Ringbuffer</code> 用来记录每个 <code>slot</code> 的状态（是否可填充、是否可消费）。</p><p>由于数组元素在内存中是连续分配的，这样可以最大程度利用 <code>Cpu Cache</code> 提升性能，但是会带来 <code>伪共享</code> 问题。</p><p>为了解决该问题，<code>Uid-Generator</code> 在 <code>Tail</code>、<code>Cursor</code>、<code>Flag-RingBuffer</code> 中采用 <code>CacheLine</code> 补齐方式。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/blog/2020-02-06-033131.png" alt="FalseSharing" title="">                </div>                <div class="image-caption">FalseSharing</div>            </figure><p>这里的说明可以看 <a href="https://github.com/baidu/uid-generator/issues/4" target="_blank" rel="noopener"> RingBuffer 中补齐问题</a> 。</p><h4 id="RingBuffer-填充时机"><a href="#RingBuffer-填充时机" class="headerlink" title="RingBuffer 填充时机"></a>RingBuffer 填充时机</h4><p><code>RingBuffer</code> 共有三种填充方式</p><ul><li><p>初始化预填充</p><p><code>RingBuffer</code> 初始化时，预先填充整个 <code>RingBuffer</code>。</p></li><li><p>即时填充</p><p>消费 <code>slot</code> 时，即时检查剩余可以消费的 <code>slot</code>（<code>tail - cursor</code>)。如果小于设定阈值，则填充空余 <code>slots</code>。</p></li><li><p>周期填充</p><p>通过 <code>Schedule</code> 线程，定时补全空闲 <code>slots</code>。</p></li></ul><p>上面分析了 <code>CachedUidGenerator</code> 依赖的数据结构，下面分析它的实现。实际上它继承了 <code>DefaultUidGenerator</code>，所以它是对 <code>DefaultUidGenerator</code> 的增强。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p><code>CachedUidGenerator</code> 在初始化时会给 <code>workerId</code> 赋值，方式与 <code>DefaultUidGenerator</code> 一致。还会初始化 <code>RingBuffer</code>，这个过程包括的操作有：</p><ol><li>根据 <code>boostPower</code> 确定 <code>RingBuffer</code> 的 <code>size</code></li><li>构造 <code>RingBuffer</code>，默认 <code>paddingFactor</code> 为 50。即当 <code>RingBuffer</code> 中剩余可用 ID 数量少于 50% 时，就触发一个异步线程往 <code>RingBuffer</code> 中填充新的 ID，直到填满为止</li><li>判断是否配置了 <code>scheduleInterval</code> 属性值，这个值表示检查填充的周期。默认不配置</li><li>初始化 <code>Put</code> 操作拒绝策略，对应属性 <code>rejectedPutBufferHandler</code>。即当 <code>RingBuffer</code> 已满，无法继续填充时的操作策略。默认情况下会丢弃<code>Put</code> 操作，记录日志。如果有需求，可以自定义实现 <code>RejectedPutBufferHandler</code> 接口</li><li>初始化 <code>Take</code> 操作拒绝策略，对应属性 <code>rejectedTakeBufferHandler</code>。即 <code>RingBuffer</code> 中没有可以使用的 ID 时的操作策略。默认情况下会记录日志并抛出 <code>UidGenerateException</code> 异常。如果有需求，可以自定义实现 <code>RejectedTakeBufferHandler</code> 接口</li><li>初始化填满 <code>RingBuffer</code> 中所有 <code>slot</code></li><li>开启 <code>buffer</code> 补丁线程（需配置 <code>scheduleInterval</code> ）</li></ol><p>第二步中的异步线程实现是 <code>UidGenerator</code> 解决时钟回拨的关键。在满足填充新的 ID 条件时，通过时间值递增得到新的时间值，而不是获取当前时间。</p><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p><code>RingBuffer</code> 初始化之后，就是取值过程了：</p><ol><li>如果剩余可用 ID 百分比低于 <code>paddingFactor</code> 参数指定值，就会异步生成若干个 ID 集合，直到将 <code>RingBuffer</code> 填满。</li><li>如果获取值的位置追上了 <code>tail</code> 指针，就会执行 <code>Task</code> 操作的拒绝策略。</li><li>获取 <code>slot</code> 中的分布式 ID。</li><li>将该 <code>slot</code> 对应的 <code>flag</code> 设置为 <code>CAN_PUT_FLAG</code>。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>绝大多数分布式 ID 生成器都是基于 <code>SnowFlake</code> 来实现的，而 <code>SnowFlake</code> 也有一些缺点。</p><p>本文中提到 <code>Uid-Generator</code> 通过自增列、<code>RingBuffer</code> 以及时间递增的措施解决了 <code>SnowFlake</code> 的传统问题。</p><p>这其中也涉及到一些计算机底层原理，关于该部分知识的解析会在其它文章中继续分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式 ID 生成器是分布式项目开发中的常用工具，弄懂其原理对理解分布式有一定的帮助。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Distributed system" scheme="http://changleamazing.com/categories/Distributed-system/"/>
    
    
      <category term="Distributed system" scheme="http://changleamazing.com/tags/Distributed-system/"/>
    
  </entry>
  
  <entry>
    <title>Redis 数据持久化</title>
    <link href="http://changleamazing.com/2020/01/02/Redis%20%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://changleamazing.com/2020/01/02/Redis%20%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-01-01T18:02:32.000Z</published>
    <updated>2020-04-20T19:39:49.477Z</updated>
    
    <content type="html"><![CDATA[<p><code>Redis</code> 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失。为了解决这个问题，<code>Redis</code> 提供了 <code>RDB</code> 持久化、<code>AOF</code> 持久化、<code>RDB-AOF</code> 混合持久化等多种持久化方式，将内存中的数据保存到磁盘中，避免数据的丢失。</p><a id="more"></a><h2 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h2><p><strong><code>RDB</code> 持久化是 <code>Redis</code> 默认的持久化方式</strong>。</p><p><code>RDB</code> 持久化会创建一个经过压缩的以 <code>.rdb</code> 结尾的二进制文件，其中<strong>包含了服务器在各个数据库中存储的键值对数据等信息</strong>。</p><h3 id="RDB-文件创建"><a href="#RDB-文件创建" class="headerlink" title="RDB 文件创建"></a>RDB 文件创建</h3><p>创建 <code>RDB</code>文件有多种方式。用户可以使用 <code>SAVE</code> 或者 <code>BGSAVE</code> 命令手动创建 <code>RDB</code> 文件，也可以通过配置 <code>save</code> 配置项使服务器在满足指定条件时自动执行 <code>BGSAVE</code> 命令。</p><h4 id="SAVE"><a href="#SAVE" class="headerlink" title="SAVE"></a>SAVE</h4><p>用户可以通过 <code>SAVE</code> 命令让 <code>Redis</code> 服务器以<strong>同步方式</strong>创建 <code>RDB</code> 文件。</p><p><code>SAVE</code> 是无参数命令，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>在 <code>SAVE</code> 命令执行期间， <code>Redis</code> 服务器将阻塞，直到 <code>RDB</code> 文件创建完毕。</p><p>当执行 <code>SAVE</code> 命令时，如果本地已经存在相应的 <code>RDB</code> 文件，则会在新的 <code>RDB</code> 文件创建完成之后删除原有的 <code>RDB</code> 文件。</p><p><code>SAVE</code> 命令的复杂度为 <code>O(N)</code>， <code>N</code> 表示 <code>Redis</code> 服务器所有数据库包含的键值对的总数。</p><h4 id="BGSAVE"><a href="#BGSAVE" class="headerlink" title="BGSAVE"></a>BGSAVE</h4><p>因为 <code>SAVE</code> 命令是同步操作，会阻塞服务器，导致执行此命令期间 <code>Redis</code> 无法执行其它命令。所以 <code>Redis</code> 提供了 <code>SAVE</code> 命令的异步版本 — <code>BGSAVE</code>。<code>BGSAVE</code> 会使用子进程创建 <code>RDB</code> 文件。</p><p><code>BGSAVE</code> 也是无参数命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; BGSAVE</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p>虽然 <code>BGSAVE</code> 的异步操作不会使服务器在创建  <code>RDB</code> 文件过程中阻塞，但是创建子进程的过程会造成短时间的阻塞。</p><p>父进程调用操作系统 <code>fork</code> 函数创建一个子进程，而 <code>fork</code> 函数在父进程占用内存越大时，创建子进程耗时越长。</p><p><code>BGSAVE</code> 命令的复杂度为 <code>O(N)</code>， <code>N</code> 表示 <code>Redis</code> 服务器所有数据库包含的键值对的总数。</p><h4 id="配置自动创建-RDB-文件"><a href="#配置自动创建-RDB-文件" class="headerlink" title="配置自动创建 RDB 文件"></a>配置自动创建 RDB 文件</h4><p>除了通过 <code>SAVE</code> 与 <code>BGSAVE</code> 命令手动创建 <code>RDB</code> 文件外，还可以通过在配置文件中配置 <code>save</code> 选项，让服务器在满足指定条件时自动执行 <code>BGSAVE</code> 命令。</p><p><code>save</code> 配置项选项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save  &lt;seconds&gt;  &lt;changes&gt;</span><br></pre></td></tr></table></figure><p><code>seconds</code>  参数指定触发持久化操作的周期，<code>changes</code>  参数用来指定触发持久化操作所需要的修改次数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">save  60  10000</span><br></pre></td></tr></table></figure><p>这个配置表示服务器在 60s 内至少执行了 10000 次修改时，服务器会自动执行 <code>BGSAVE</code> 命令。</p><p><code>Redis</code> 默认持久化方式为 <code>RDB</code>，如果不改变默认配置，那么 <code>Redis</code> 使用的 <code>save</code> 选项为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save  60  10000</span><br><span class="line">save  300  100</span><br><span class="line">save  3600  1</span><br></pre></td></tr></table></figure><p>这里配置了多个 <code>save</code> 选项，当其中任意一个条件被满足时就会触发服务器执行 <code>BGSAVE</code> 命令。</p><blockquote><p>为了避免由于同时使用多个 <code>RDB</code> 文件创建方式或者配置多个 <code>save</code> 选项导致服务器频繁创建 <code>RDB</code> 文件，<code>Redis</code> 服务器在每次成功创建 <code>RDB</code> 文件后，会将负责自动触发 <code>BGSAVE</code> 命令的时间计数器以及修改次数计数器清零并重新开始计数。</p></blockquote><h4 id="SAVE-与-BGSAVE-的选择"><a href="#SAVE-与-BGSAVE-的选择" class="headerlink" title="SAVE 与 BGSAVE 的选择"></a>SAVE 与 BGSAVE 的选择</h4><p>由于 <code>SAVE</code> 命令会阻塞 <code>Redis</code> 服务器向其它客户端服务，所以如果我们需要创建 <code>RDB</code> 文件时同时为其它客户端服务，就只能使用 <code>BGSAVE</code> 命令创建 <code>RDB</code> 文件。</p><p>而 <code>SAVE</code> 命令更适合维护离线 <code>Redis</code> 服务器，因为它不会创建子进程而消耗额外的内存。</p><h3 id="RDB-优缺点"><a href="#RDB-优缺点" class="headerlink" title="RDB 优缺点"></a>RDB 优缺点</h3><p><code>RDB</code> 持久化可以生成紧凑的 <code>RDB</code> 文件，并且使用 <code>RDB</code>  文件恢复数据也很快.</p><p>但是无论是 <code>SAVE</code> 命令还是 <code>BGSAVE</code> 命令，当服务器停机时，服务器丢失的数据量取决于创建 <code>RDB</code> 文件的时间间隔：间隔越长，丢失数据越多。如果提高执行 <code>SAVE</code> 或者 <code>BGSAVE</code> 命令的频率，会导致 <code>Redis</code> 服务器性能骤降，甚至低于传统关系型数据库。</p><p>所以 <code>RDB</code> 持久化更像是一种备份手段而不是一种常规数据持久化方案。</p><h2 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h2><p><code>RDB</code> 持久化是全量式操作，而 <code>AOF</code> 是增量操作。</p><p>服务器每次执行完写命令之后，都会以<strong>协议文本</strong>的方式将被执行的写命令追加到 <code>AOF</code> 文件的结尾。在服务器停机之后，只需要重新执行 <code>AOF</code> 文件中保存的 <code>Redis</code> 命令，就可以将数据库恢复至停机之前的状态。</p><blockquote><p><code>AOF</code> 文件中唯一不是用户执行的命令是 <code>SELECT</code>，这是服务器根据用户正在使用的数据库号码自动加上的。</p></blockquote><p>同步命令到 AOF 文件的整个过程可以分为三个阶段：</p><ol><li>命令传播：<code>Redis</code> 将执行完的命令、命令的参数、命令的参数个数等信息发送到 <code>AOF</code> 程序中。</li><li>缓存追加：AOF 程序根据接收到的命令数据，<strong>将命令转换为网络通讯协议的格式</strong>，然后将协议内容追加到服务器的 AOF 缓存中。</li><li>文件写入和保存：AOF 缓存中的内容被写入到 <code>AOF</code> 文件末尾，如果设定的 <code>AOF</code> 保存条件被满足的话， <code>fsync</code> 函数或者 <code>fdatasync</code> 函数会被调用，将写入的内容真正地保存到磁盘中。</li></ol><p>由于默认持久化方式为 <code>RDB</code>，所以用户需要配置 <code>appendonly</code> 选项来打开 <code>AOF</code> 持久化功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly  yes</span><br></pre></td></tr></table></figure><p>打开 <code>AOF</code> 持久化功能之后，<code>Redis</code> 在默认情况下会创建一个名为 <code>appendonly.aof</code> 的文件作为 <code>AOF</code> 文件。</p><h3 id="AOF-文件冲洗频率"><a href="#AOF-文件冲洗频率" class="headerlink" title="AOF 文件冲洗频率"></a>AOF 文件冲洗频率</h3><blockquote><p>为了提高程序的写入性能，现代化的操作系统通常会把针对硬盘的多次写操作优化成一次写操作。当程序调用 <code>write</code> 系统调用对文件进行写入时，系统会先将数据写入位于内存的缓冲区中，当到达指定的时限或者满足某些写入条件时，系统才会调用 <code>fsync</code> 或者 <code>fdatasync</code> 函数，将缓冲区数据冲洗至硬盘。</p></blockquote><p>上述机制虽然能提高写入性能，但是对于持久化功能来说，两次执行冲洗操作的间隔会影响持久化的安全性。</p><p><code>Redis</code> 提供了 <code>appendfsync</code> 选项来控制系统冲洗 <code>AOF</code> 文件的频率。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync  always|everysec|no</span><br></pre></td></tr></table></figure><p><code>appendfsync</code> 有三个可选值，分别代表的意义如下：</p><ul><li>always：每执行一个写命令，就对 <code>AOF</code> 文件执行一次冲洗操作</li><li>everysec：每隔 1s，就对 <code>AOF</code> 文件执行一次冲洗操作</li><li>no：不主动对  <code>AOF</code> 文件执行冲洗操作，由操作系统决定何时对 <code>AOF</code> 进行冲洗。</li></ul><p>对于这三种冲洗策略来说，不同的安全性对应着不同的性能：</p><ul><li>always：最多只会丢失一个命令的数据，但是由于对磁盘的频繁写入，导致 <code>Redis</code> 服务器性能骤降至关系型数据库的水平</li><li>everysec：最多丢失 1s 之内产生的命令数据，这是一种兼顾性能与安全性的折中方案</li><li>no：最多丢失服务器最后一次冲洗 <code>AOF</code> 文件之后产生的所有命令数据，数据量的大小取决于系统冲洗 <code>AOF</code> 文件的频率，不安全</li></ul><p>对比之下，<code>Redis</code> 选择 <code>everysec</code> 作为默认的冲洗策略，除非有明确的需求，否则也不应该修改该选项值。</p><h3 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h3><p>由于 <code>AOF</code> 的增量特性，<code>AOF</code> 文件会越来越大，其中也会存在一些对相同键执行过的多次修改操作，导致有一部分命令是冗余的。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT 0</span><br><span class="line"></span><br><span class="line">SET  msg  &quot;hello world!&quot;</span><br><span class="line"></span><br><span class="line">SET  msg  &quot;good  bye&quot;</span><br></pre></td></tr></table></figure><p>实际上，上述三条命令可以直接将第二条去掉，执行后最终效果与原来是一致的。这种冗余命令的存在增加了 <code>AOF</code> 文件的体积，恢复数据时耗费时间也越多。</p><p>为了减少冗余命令，<code>Redis</code> 提供了 <code>AOF</code> 重写功能，该功能会能够生成一个全新的 <code>AOF</code> 文件，其中只包含恢复当前数据库所需要的尽可能少的命令。</p><p>对于上面的三条命令来说，<code>AOF</code> 重写之后就会变成如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 0</span><br><span class="line"></span><br><span class="line">SET  msg  &quot;good  bye&quot;</span><br></pre></td></tr></table></figure><p> <code>AOF</code> 重写操作可以通过执行 <code>BGREWRITEAOF</code> 命令或者配置选项来触发。</p><h4 id="BGREWRITEAOF"><a href="#BGREWRITEAOF" class="headerlink" title="BGREWRITEAOF"></a>BGREWRITEAOF</h4><p><code>BGREWRITEAOF</code> 是一个无命令参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;  BGREWRITEAOF</span><br><span class="line">Background append only file rewriting started</span><br></pre></td></tr></table></figure><p>复杂度为 <code>O(N)</code>,<code>N</code> 表示服务器所有数据库包含的键值对总数。</p><p><code>BGREWRITEAOF</code> 是一个异步命令，<code>Redis</code> 服务器接收到该命令之后会创建一个子进程来扫描数据库并生成新的 <code>AOF</code> 文件。当新的 <code>AOF</code> 文件生成完毕，子进程就会退出并通知 <code>Redis</code>，<code>Redis</code> 就会使用新的 <code>AOF</code> 文件代替原有 <code>AOF</code> 文件。</p><p>如果发送 <code>BGREWRITEAOF</code> 请求时，服务器正在创建 <code>RDB</code> 文件，那么服务器会将 <code>AOF</code> 重写操作延后到 <code>RDB</code> 文件创建完毕之后再执行，避免两个写操作同时执行导致服务器性能下降。</p><p>如果服务器在执行重写操作的过程中，又收到了新的 <code>BGREWRITEAOF</code> 命令，那么会返回以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt;  BGREWRITEAOF</span><br><span class="line">(error) ERR Background append only file rewriting already in progress</span><br></pre></td></tr></table></figure><h4 id="AOF-重写配置选项"><a href="#AOF-重写配置选项" class="headerlink" title="AOF 重写配置选项"></a>AOF 重写配置选项</h4><p>以下两个配置选项可以设置 <code>Redis</code> 触发 <code>BGREWRITEAOF</code> 命令的条件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size  &lt;value&gt;</span><br><span class="line">auto-aof-rewirte-percentage  &lt;value&gt;</span><br></pre></td></tr></table></figure><p><code>auto-aof-rewrite-min-size</code> 选项用于设置触发 <code>AOF</code> 重写所需要的最小 <code>AOF</code> 文件体积。</p><p>例如对于该选项默认值来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size  64mb</span><br></pre></td></tr></table></figure><p>当 <code>AOF</code> 文件体积小于 64mb 时，服务器不会自动执行 <code>BGREWRITEAOF</code> 命令。</p><p><code>auto-aof-rewirte-percentage</code> 选项配置的值是触发 <code>AOF</code> 重写所需要的文件体积增大比例。</p><p>例如对于该选项默认值来说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewirte-percentage  100</span><br></pre></td></tr></table></figure><p>表示当前 <code>AOF</code> 文件体积比最后一次 <code>AOF</code> 文件重写之后的体积增大一倍时，会触发 <code>BGREWRITEAOF</code> 命令。</p><p>如果 <code>Redis</code> 还没有执行过 <code>AOF</code> 文件重写操作，那就会把启动服务器时使用的 <code>AOF</code> 文件体积当做最后一次 <code>AOF</code> 文件重写的体积。</p><p>假设 <code>AOF</code> 文件上次重写之后体积为 300MB，当前 <code>AOF</code> 文件达到 600MB 时,才会触发 <code>AOF</code> 重写操作。</p><h3 id="AOF-持久化优缺点"><a href="#AOF-持久化优缺点" class="headerlink" title="AOF 持久化优缺点"></a>AOF 持久化优缺点</h3><p><code>AOF</code> 持久化的安全性是 <code>RDB</code> 望尘莫及的，正常情况下配置 <code>appendonly everysec</code> 可以将数据丢失的时间压缩至 1s 以内。</p><p>当然，<code>AOF</code> 也有相应的缺点：</p><ul><li><code>AOF</code> 使用协议文本来存储操作,所以文件体积相对于包含相同数据的 <code>RDB</code> 文件来说会大得多，生成 <code>AOF</code> 文件所需的时间也比生成 <code>RDB</code> 文件时间更长</li><li><code>AOF</code> 持久化需要通过执行 <code>AOF</code> 文件中保存的命令来恢复数据库，所以 <code>AOF</code> 持久化数据恢复速度比 <code>RDB</code> 文件恢复慢很多，并且数据库体积越大，差距越明显</li><li><code>AOF</code> 使用的 <code>BGREWRITEAOF</code> 命令也需要创建子进程，如果数据库体积较大，进行 <code>AOF</code> 文件重写会占用大量资源，并导致服务器短暂阻塞。</li></ul><h2 id="RDB-AOF-混合持久化"><a href="#RDB-AOF-混合持久化" class="headerlink" title="RDB-AOF 混合持久化"></a>RDB-AOF 混合持久化</h2><p>由于 <code>RDB</code> 持久化与 <code>AOF</code> 持久化都有各自优缺点，用户也较难抉择。 <code>Redis4.0</code> 开始，引入了 <code>RDB-AOF</code> 混合持久化模式，这种模式基于 <code>AOF</code> 持久化模式构建。所以需要用户打开 <code>AOF</code> 持久化功能，并且配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aof-use-rdb-preamble  yes</span><br></pre></td></tr></table></figure><p>此后，当 <code>Redis</code> 执行 <code>AOF</code> 重写操作时，会根据数据库当前的状态生成出对应的 <code>RDB</code> 数据，并且将这部分数据写入新建的 <code>AOF</code> 文件当中，而在此之后执行的写操作，会以协议文本的方式追加到新的 <code>AOF</code> 文件末尾（即 <code>RDB</code> 数据后）。</p><p>当支持 <code>RDB-AOF</code> 混合持久化模式的 <code>Redis</code> 服务器启动并载入 <code>AOF</code> 文件时，首先会检查 <code>AOF</code> 文件头部是否包含 <code>RDB</code> 格式的内容。如果包含，那服务器就会先载入 <code>RDB</code> 数据，之后再载入 <code>AOF</code> 数据。</p><p><code>RDB-AOF</code> 混合持久化综合了 <code>RDB</code> 持久化与 <code>AOF</code> 持久化的优点。既可以通过 <code>AOF</code> 文件中的 <code>RDB</code> 数据快速恢复数据，又可以通过 <code>AOF</code> 包含的 <code>AOF</code> 数据将丢失数据的时间压缩至 1s 之内。</p><p><code>Redis</code>  现在已发布 5.0 版本，默认是没有打开 <code>RDB-AOF</code> 混合持久化功能的。不过 <code>Redis</code> 作者声称该持久化方式之后会取代 <code>RDB</code>  持久化成为 <code>Redis</code> 默认持久化方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失。为了解决这个问题，&lt;code&gt;Redis&lt;/code&gt; 提供了 &lt;code&gt;RDB&lt;/code&gt; 持久化、&lt;code&gt;AOF&lt;/code&gt; 持久化、&lt;code&gt;RDB-AOF&lt;/code&gt; 混合持久化等多种持久化方式，将内存中的数据保存到磁盘中，避免数据的丢失。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://changleamazing.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changleamazing.com/tags/Redis/"/>
    
      <category term="Data Persistence" scheme="http://changleamazing.com/tags/Data-Persistence/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 源码解析</title>
    <link href="http://changleamazing.com/2019/12/12/HashMap/"/>
    <id>http://changleamazing.com/2019/12/12/HashMap/</id>
    <published>2019-12-11T16:52:50.000Z</published>
    <updated>2020-05-10T06:27:20.651Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于 <code>JDK8</code> 源码深入分析 <code>HashMap</code> 的结构与重要操作，并梳理一些面试中的常见问题。</p><a id="more"></a><h2 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://changleamazing-1253815386.cos.ap-guangzhou.myqcloud.com/2019/06/06/15597572496204.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><h3 id="DEFAULT-INITIAL-CAPACITY"><a href="#DEFAULT-INITIAL-CAPACITY" class="headerlink" title="DEFAULT_INITIAL_CAPACITY"></a>DEFAULT_INITIAL_CAPACITY</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>HashMap 中槽数量的默认值，即 HashMap 中 table 数组的 <code>table.length</code>;</p><p>HashMap 初始化时，如果未指定 <code>capacity</code> 时，即设定 <code>capacity</code> 为此值。</p><h3 id="MAXIMUM-CAPACITY"><a href="#MAXIMUM-CAPACITY" class="headerlink" title="MAXIMUM_CAPACITY"></a>MAXIMUM_CAPACITY</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>HashMap 中槽数量的最大值。</p><p>HashMap 初始化时，如果指定的 <code>capacity</code> 大于该值，则将 <code>capacity</code> 设置为该值。</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>HashMap 中装载数据的桶的数组。<code>table.length</code> 在分配数据之后长度总是 2 的幂。（除了在自举机制中一些操作允许长度为 0）</p><h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><p>装载了所有键值对的集合，在遍历 HashMap 时一般使用这个集合，比使用 keySet 集合遍历速度大约快 1 倍。</p><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>HashMap 中目前存放的键值对的个数。</p><h3 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>HashMap 结构更改的次数（即增删操作的次数）。用于在遍历时保证<code>fail-fast</code> 机制生效。</p><h3 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h3><p>HashMap 中存放键值对的阈值，当 <code>size &gt; threshold</code> 时，会触发 <code>table</code> 数组扩容操作。 </p><p><code>table</code> 数组没有被分配数据时，<code>threshold</code> 值等于 0 或者是 <code>table.length</code>。而在 <code>table</code> 数组被分配数据之后，它的值等于 <code>table.length * loadFactor</code>。</p><h3 id="loadFactor"><a href="#loadFactor" class="headerlink" title="loadFactor"></a>loadFactor</h3><p>装载因子：即负载率；默认为 <code>0.75</code>。</p><p>JDK 1.7 中提到，</p><blockquote><p>As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.</p></blockquote><p>意思是 <code>0.75</code> 在时间和空间上提供了很好的折中。由于 <code>threshold = capacity * loadFactor</code> ，如果 <code>loadFactor</code> 设置过高，可以节省少量空间，但是会导致 <code>threshold</code> 和 <code>capacity</code> 非常接近， <code>Hash 碰撞</code> 的概率增大，一定程度上提高了 <code>put</code> 和 <code>get</code> 操作的耗时；如果 <code>loadFactor</code> 设置过低，则会产生相反的效果。</p><h3 id="TREEIFY-THRESHOLD"><a href="#TREEIFY-THRESHOLD" class="headerlink" title="TREEIFY_THRESHOLD"></a>TREEIFY_THRESHOLD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p><code>table</code>数组中的每个槽中存储的数据量，在 <strong>大于</strong> 该值时，槽中存储数据的数据结构会变为红黑树。</p><p>###　UNTREEIFY_THRESHOLD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>table`数组中的每个槽中存储的数据量，在 <strong>小于</strong> 该值时，槽中存储数据的数据结构会变为链表。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><h3 id="public-HashMap"><a href="#public-HashMap" class="headerlink" title="public HashMap()"></a>public HashMap()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最常用的构造方法。</p><p><code>loadFactor</code> 为默认值 0.75 ; </p><h3 id="public-HashMap-int-initialCapacity"><a href="#public-HashMap-int-initialCapacity" class="headerlink" title="public HashMap(int initialCapacity)"></a>public HashMap(int initialCapacity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>调用 <code>public HashMap(int initialCapacity, float loadFactor);</code></p><p>手动设置 HashMap 的初始化容量。</p><p><code>loadFactor</code> 为默认值 0.75 ; </p><h3 id="public-HashMap-int-initialCapacity-float-loadFactor"><a href="#public-HashMap-int-initialCapacity-float-loadFactor" class="headerlink" title="public HashMap(int initialCapacity, float loadFactor)"></a>public HashMap(int initialCapacity, float loadFactor)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadFactor</code> 为自定义值 ; </p><h4 id="static-final-int-tableSizeFor-int-cap"><a href="#static-final-int-tableSizeFor-int-cap" class="headerlink" title="static final int tableSizeFor(int cap)"></a>static final int tableSizeFor(int cap)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释可知，该方法的返回值为 2 的幂。</p><p>实际上这个算法返回的是，大于 cap 的最接近 cap 的 2 的 次幂。</p><p>该构造方法，实际上控制的是 <code>threshold</code> 而不是直接设置 <code>capacity</code>。</p><h3 id="public-HashMap-Map-lt-extends-K-extends-V-gt-m"><a href="#public-HashMap-Map-lt-extends-K-extends-V-gt-m" class="headerlink" title="public HashMap(Map&lt;? extends K, ? extends V&gt; m)"></a>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用另一个 map 构造一个新的 hashmap。</p><p><code>loadFactor</code> 为默认值。</p><h4 id="final-void-putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict"><a href="#final-void-putMapEntries-Map-lt-extends-K-extends-V-gt-m-boolean-evict" class="headerlink" title="final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)"></a>final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 若 evict 为 false,代表是在创建 hashMap 时调用了这个函数;若 evict　为true,代表是在创建 hashMap 后才调用这个函数，例如 putAll 函数。*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;<span class="comment">// 阿里推荐初始化值</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化时， <code>ft = ((float)s / loadFactor) + 1.0F</code>,即为 <code>table.length + 1</code>。然后调用 <code>threshold = tableSizeFor(t)</code>；这样 <code>threshold</code> 的值，是 <code>2 * table.length</code>。所以，新增元素不会立刻导致扩容。</p><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><h3 id="public-V-get-Object-key"><a href="#public-V-get-Object-key" class="headerlink" title="public V get(Object key)"></a>public V get(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="static-final-int-hash-Object-key"><a href="#static-final-int-hash-Object-key" class="headerlink" title="static final int hash(Object key)"></a>static final int hash(Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是调用了 <code>key.hashCode( )</code> 方法，实际就是 <code>Object</code> 类中的 <code>hashCode()</code> 方法。作用是将对象的地址映射成一个整数值，尽量保证随机性。<br>而 HashMap 中没有直接使用 <code>Object</code> 中的 <code>hashCode()</code> 的返回值作为 <code>hash()</code> 函数的结果，而是增加了 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code> 这一步,将 <code>hashCode()</code> 的返回值与向右移动 16 位的 h 做异或运算。这里，(h &gt;&gt;&gt; 16) 叫做 <strong>扰动函数</strong>，该扰动函数保证了函数最后的返回值的后十六位中，是高位与低位共同运算出的结果。增加了节点在 <code>table</code> 数组中分布的随机性。</p><blockquote><p>结果显示，当 <code>HashMap</code> 数组长度为 512 时，这个时候会取低 9 位的值来决定新增节点的位置。在有扰动函数的情况下，碰撞会减少 10%。</p></blockquote><h4 id="final-Node-lt-K-V-gt-getNode-int-hash-Object-key"><a href="#final-Node-lt-K-V-gt-getNode-int-hash-Object-key" class="headerlink" title="final Node&lt;K,V&gt; getNode(int hash, Object key)"></a>final Node&lt;K,V&gt; getNode(int hash, Object key)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">       Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">       <span class="comment">/* 条件判断，判断 `table` 数组不为空，且有元素存在；在该节点对应的槽里面也要有元素存在 */</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 判断 key 是不是该槽位中的第一个元素。</span></span><br><span class="line">           <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">               ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">               <span class="keyword">return</span> first;</span><br><span class="line">           <span class="comment">// 如果该槽位中不止存在一个值，判断该槽位的节点是不是树节点    </span></span><br><span class="line">           <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//如果是树节点，直接调用树查找节点的方法。并返回查找到的值</span></span><br><span class="line">               <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                   <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">               <span class="comment">// 如果该槽位中的数据仍用链表存储。则直接遍历判断元素的 key 是不是等于要查找的 key</span></span><br><span class="line">               <span class="keyword">do</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                       ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">               &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这是 HashMap 查找方法的主流程，相对比较简单。<br>在进行最外层判断时，使用到了 <code>tab[(n - 1) &amp; hash]</code> 这段代码。<br><code>tab[(n - 1) &amp; hash]</code> 是 <code>table.length</code> 必须保持 2 的 次幂的关键。<br>在得到一个元素 key 哈希运算返回值 <code>hash</code> 后，为了找到该元素在 <code>table</code> 中具体分布在哪个槽中，一般会使用 <code>hash % table.length</code>。<br><strong>当 <code>table.length</code> 等于 2^n 时， 存在<code>hash % table.length = hash &amp; (table.length - 1)</code></strong>。这样，由于位运算更快，可以更加快速的找到每一个节点对应的槽位。</p><h2 id="增-改"><a href="#增-改" class="headerlink" title="增/改"></a>增/改</h2><h3 id="public-V-put-K-key-V-value"><a href="#public-V-put-K-key-V-value" class="headerlink" title="public V put(K key, V value)"></a>public V put(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//evict　为true,代表是在创建 hashMap 后才调用这个函数</span></span><br><span class="line">    <span class="comment">/** onlyIfAbsent 表示是否只在没有该节点映射时，put 才生效（是否允许覆盖）。</span></span><br><span class="line"><span class="comment">        false 表示允许覆盖操作 **/</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 HashMap 中已经存在该节点的映射（更新操作），返回值会是旧节点的 value。<br>如果不存在该节点的映射（新增操作），返回值会是 null。<br>所以<strong>可以用返回值来判断原来的 HashMap 中是否存在关于该节点的映射</strong>，在某些时刻很有用。</p><h4 id="final-V-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#final-V-putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)"></a>final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">// 如果数组没有初始化，或者长度为 0，则重新设置数组长度</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">// 如果该节点 key 对应的槽位没有元素，直接新建节点将该元素放入该槽位</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">/** 如果槽位的第一个元素 p 的 key 与 带插入的节点的 key 相等，则直接令 e = p，此时 e.value 被 p.value 替代，相当于更新操作 **/</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">/** 如果槽位的元素是树节点，调用树的插入值的方法</span></span><br><span class="line"><span class="comment">            else if (p instanceof TreeNode)</span></span><br><span class="line"><span class="comment">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span></span><br><span class="line"><span class="comment">            // 槽中元素为链表节点</span></span><br><span class="line"><span class="comment">            else &#123;</span></span><br><span class="line"><span class="comment">                for (int binCount = 0; ; ++binCount) &#123;</span></span><br><span class="line"><span class="comment">                    // 判断 p 是否为尾结点</span></span><br><span class="line"><span class="comment">                    if ((e = p.next) == null) &#123;</span></span><br><span class="line"><span class="comment">                        p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                        // 判断新增节点后，是否需要更新数据结构，槽中节点数等于 8 就更新</span></span><br><span class="line"><span class="comment">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span></span><br><span class="line"><span class="comment">                            treeifyBin(tab, hash);</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    //如果链表中有元素的 key 等于 e.key，则更新</span></span><br><span class="line"><span class="comment">                    if (e.hash == hash &amp;&amp;</span></span><br><span class="line"><span class="comment">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span></span><br><span class="line"><span class="comment">                        break;</span></span><br><span class="line"><span class="comment">                    p = e;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            // 如果 e 不为 null，说明之前存在该 key 的映射，</span></span><br><span class="line"><span class="comment">            if (e != null) &#123; // existing mapping for key</span></span><br><span class="line"><span class="comment">                V oldValue = e.value;</span></span><br><span class="line"><span class="comment">                // 允许覆盖则更新节点值</span></span><br><span class="line"><span class="comment">                if (!onlyIfAbsent || oldValue == null)</span></span><br><span class="line"><span class="comment">                    e.value = value;</span></span><br><span class="line"><span class="comment">                // 为 linkedHashMap 提供的函数，将最近访问的元素置于链表尾部，保证链表有序性</span></span><br><span class="line"><span class="comment">                afterNodeAccess(e);</span></span><br><span class="line"><span class="comment">                return oldValue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        // 修改次数增加</span></span><br><span class="line"><span class="comment">        ++modCount;</span></span><br><span class="line"><span class="comment">        // 判断是否需要扩容</span></span><br><span class="line"><span class="comment">        if (++size &gt; threshold)</span></span><br><span class="line"><span class="comment">            resize();</span></span><br><span class="line"><span class="comment">        // 为 linkedHashMap 提供的函数，回调删除头节点</span></span><br><span class="line"><span class="comment">        afterNodeInsertion(evict);</span></span><br><span class="line"><span class="comment">        return null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure><h3 id="public-V-putIfAbsent-K-key-V-value"><a href="#public-V-putIfAbsent-K-key-V-value" class="headerlink" title="public V putIfAbsent(K key, V value)"></a>public V putIfAbsent(K key, V value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第四个参数 <code>onlyIfAbsent</code> 为 true 表示只允许插入操作，更新操作不生效。</p><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="public-V-remove-Object-key"><a href="#public-V-remove-Object-key" class="headerlink" title="public V remove(Object key)"></a>public V remove(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果返回值为空，表示 HashMap 中不存在该 key 对应的节点。否则，返回对应节点的 value。</p><h4 id="final-Node-lt-K-V-gt-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable"><a href="#final-Node-lt-K-V-gt-removeNode-int-hash-Object-key-Object-value-boolean-matchValue-boolean-movable" class="headerlink" title="final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)"></a>final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">        <span class="comment">// 判断数组有元素存在且 key 对应的槽位有元素存在</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">            <span class="comment">// 如果槽中第一个元素 p 是要删除的节点，令 node = p</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            <span class="comment">// 槽中第一个元素 p 不是要删除的节点，在后继节点中寻找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 槽中元素存储在 RBT 中，令 node 等于从树中查找到的节点</span></span><br><span class="line">                <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                <span class="comment">// 槽中元素存储在链表中，令 node 等于从链表中查找到的节点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// node 不为空, 且不需要匹配 value 或者成功匹配到 value，删除节点</span></span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);       </span><br><span class="line">                <span class="comment">// 如果要删除的节点为槽中第一个节点，则将第二个节点作为首节点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><h3 id="final-Node-lt-K-V-gt-resize"><a href="#final-Node-lt-K-V-gt-resize" class="headerlink" title="final Node&lt;K,V&gt;[] resize()"></a>final Node&lt;K,V&gt;[] resize()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果数组已经初始化过且 table.length != 0</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/** 如果数组原来的长度为 MAXIMUM_CAPACITY，table.length 无法扩大，</span></span><br><span class="line"><span class="comment">            修改 threshold = Integer.MAX_VALUE 使 map 可以继续存放元素</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 扩大 table.length = min(oldCap * 2 ,MAXIMUM_CAPACITY)</span></span><br><span class="line">            <span class="comment">//只有原来 oldCap.length &gt;= 16，会使阈值翻倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原来 table.length = 0 且 threshold ！= 0 ，在带参非集合初始化时会出现这种情况。</span></span><br><span class="line">        <span class="comment">//设置 newCap 为初始化时构造函数中 tableSizeFor() 方法返回的 threshold </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold    </span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">// table.length = 0 &amp;&amp; threshold = 0 ，无参初始化时出现这种情况</span></span><br><span class="line">        <span class="comment">// 设置 cap 和 threshold 为默认值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有两种情况会符合该判断</span></span><br><span class="line">        <span class="comment">//1. 原来的 table.length * 2 &gt;= MAXIMUM_CAPACITY，</span></span><br><span class="line">        此时将 threshold 设置为 Integer.MAX_VALUE</span><br><span class="line">        <span class="comment">//2. 当原来的 table.length &lt; 16 时，设置 threshold = min(MAXIMUM_CAPACITY,threshold * loadFactor)。(故意设置 loadFactor 很高时，会出现 threshold * loadFactor &gt; MAXIMUM_CAPACITY)</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 移动元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//方便 GC</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">// 如果该槽中只有一个元素，新数组的槽中依然只有它一个元素</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">// 如果槽中数据结构为 RBT </span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">// 如果槽中数据结构为链表</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">// 确定该节点在 resize 之后是否会改变索引值</span></span><br><span class="line">                            <span class="comment">// e.hash &amp; oldCap = 0，说明索引值在 resize 之后不会改变</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//将元素放在索引为 index 的链表尾部</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                <span class="comment">//这里说明了 JDK8 是尾插法    </span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                 <span class="comment">//将元素放在索引为 index + oldCap 的链表尾部</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//将链表尾结点置空</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中有一些很关键的点，</p><p>移动元素前会使判断 <code>e.hash &amp; oldCap</code> 是否等于 0。假设 <code>oldCap</code> 为 <code>2^k</code> ，元素<code>m</code> 的索引为 <code>oldIndex</code>，<code>hash(m)</code> 的值为 <code>hash</code>，存在 <code>oldIndex= hash &amp; ( 2^k - 1 )</code>。<strong>(2^k - 1) 的结果的二进制表达式是 k 个 1。所以 <code>oldIndex</code>的结果等于 <code>hash</code> 的二进制表达式的后 <code>k</code> 位的值。</strong></p><p>扩容后，新数组的长度 <code>newCap</code> 为 <code>2^(k + 1)</code>。元素 <code>m</code> 在新数组中的索引 <code>newIndex = hash &amp; (2 ^ (k + 1) - 1)</code>。同上，<code>newIndex</code> 的结果等于 <code>hash</code> 的二进制表达式的后 <code>k + 1</code> 位的值。用 <code>b</code> 代表 <code>hash</code>二进制表示的第<code>k + 1</code>位，那么 <code>newIndex - oldIndex</code> 就等于 <code>b</code> 代表的值。</p><p><code>b</code>的权值为 <code>2^k</code>等于 <code>oldCap</code>。当 <code>b = 0</code>时， <code>newIndex = oldIndex</code>；当 <code>b = 1</code>时，<code>newIndex = oldIndex + oldCap</code>。所以，元素<code>m</code>在新数组的位置就由<code>hash</code>的第 <code>k + 1</code>位的值确定，这个值就等于<code>hash &amp; oldCap</code>。</p><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash 了。</p><p>另一个关键点，在于移动时，<strong>使用尾插法，保持了元素在原来槽中的相对顺序</strong>。这个方法，解决了 JDK1.7 中多线程访问 HashMap 时，<code>resize</code> 过程中会出现的循环链表的问题。<strong>但 HashMap 仍然不是线程安全的</strong>。</p><h2 id="重要问题"><a href="#重要问题" class="headerlink" title="重要问题"></a>重要问题</h2><h3 id="JDK8-相对于-JDK7-优化点有哪些"><a href="#JDK8-相对于-JDK7-优化点有哪些" class="headerlink" title="JDK8 相对于 JDK7 优化点有哪些"></a>JDK8 相对于 JDK7 优化点有哪些</h3><p>JDK8 对于 <code>HashMap</code> 的改动很大。主要的优化点在：</p><ol><li><code>HashMap</code> 中使用的数据结构新增红黑树，当哈希冲突严重时，查找元素的耗时也不会恶化到 O(n) 级别。</li><li>插入元素的方式。JDK8 采用了尾插法插入元素，在扩容时保持了原来元素的相对顺序。而 JDK7 采用的是头插法，多线程扩容时可能会导致产生闭环问题。</li><li>扩容时，<code>HashMap</code> 中元素索引直接由元素 <code>hashcode</code>来计算是原位置或者是原位置 + 数组长度。而在 JDK7 中，元素扩容时，都会调用 <code>hash()</code> 方法重新计算元素的 <code>hashcode</code> ，再决定元素在数组中的索引。</li></ol><h3 id="JDK1-7-死循环问题"><a href="#JDK1-7-死循环问题" class="headerlink" title="JDK1.7 死循环问题"></a>JDK1.7 死循环问题</h3><p>当多线程添加元素并且引起扩容时，可能会触发 <code>HashMap</code> 中某个链表死循环。主要的原因是 JDK1.7 使用的头插法，导致原来两个节点的顺序在扩容后被翻转，多线程操作时就可能引起死循环。而在 JDK1.8 中，扩容时使用的是尾插法插入元素，这样元素的相对顺序不会改变，所以不会再出现死循环的问题。</p><h3 id="JDK8-线程安全问题"><a href="#JDK8-线程安全问题" class="headerlink" title="JDK8 线程安全问题"></a>JDK8 线程安全问题</h3><p>JDK8 中解决了 <code>HashMap</code> 死循环之后，依然不是线程的。</p><p>举两个例子：</p><ol><li><p>当多线程放入两个 <code>hashcode</code> 一致的元素时，两个元素会放入相同的槽中，当他们获取到了同一个链表尾部元素时，会将各自的元素标记为链表尾部，导致其中一个元素丢失。</p></li><li><p>当多线程放入新元素时，都会执行到 <code>++size</code> 这一步，表示 <code>HashMap</code> 中保存的元素数量增加了，但是 <code>size</code> 并不是 <code>volatile</code> 修饰的，多线程操作时可能会导致值被覆盖，从而 <code>size</code> 与实际数据不对。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于 &lt;code&gt;JDK8&lt;/code&gt; 源码深入分析 &lt;code&gt;HashMap&lt;/code&gt; 的结构与重要操作，并梳理一些面试中的常见问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java Collections,SourceCode" scheme="http://changleamazing.com/categories/Java-Collections-SourceCode/"/>
    
    
      <category term="SourceCode" scheme="http://changleamazing.com/tags/SourceCode/"/>
    
      <category term="HashMap" scheme="http://changleamazing.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Redis 分布式锁</title>
    <link href="http://changleamazing.com/2019/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://changleamazing.com/2019/11/18/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2019-11-17T16:52:50.000Z</published>
    <updated>2020-04-20T19:41:16.577Z</updated>
    
    <content type="html"><![CDATA[<p>在单节点中，需要用并发线程都能访问到的资源的状态变化来控制同步。在分布式应用中，使用应用所有节点都能访问到的 <code>Redis</code> 中的某个 <code>key</code> 来控制多节点访问。</p><a id="more"></a><h2 id="单节点-Redis-分布式锁"><a href="#单节点-Redis-分布式锁" class="headerlink" title="单节点 Redis 分布式锁"></a>单节点 Redis 分布式锁</h2><h3 id="setnx"><a href="#setnx" class="headerlink" title="setnx"></a><code>setnx</code></h3><p><code>setnx</code> 指令会在 <code>key</code> 不存在的情况下放入 <code>redis</code>，如果存在则不会设置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;setnx lock:distributed true</span><br><span class="line">OK</span><br><span class="line">...</span><br><span class="line">other code</span><br><span class="line">...</span><br><span class="line">&gt;del lock:distributed</span><br></pre></td></tr></table></figure><p>这种方式的问题在于，执行到 other code 时，程序出现异常，导致 <code>del</code> 指令不会被执行，<code>key</code> 没有被释放，这样会陷入死锁。</p><h3 id="setnx-then-expire"><a href="#setnx-then-expire" class="headerlink" title="setnx then expire"></a><code>setnx then expire</code></h3><p>为了解决死锁，乍一看可以使用 <code>expire</code> 来给 <code>key</code> 设置超时时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;setnx lock:distributed true</span><br><span class="line">OK</span><br><span class="line">&gt;expire lock:distributed 5</span><br><span class="line">...</span><br><span class="line">other code</span><br><span class="line">...</span><br><span class="line">&gt;del lock:distributed</span><br></pre></td></tr></table></figure><p>这种处理其实仍然有问题，因为 <code>setnx</code> 与 <code>expire</code> 不是原子操作， 执行 <code>expire</code> 语句之前可能发生异常。死锁仍然会出现。</p><h3 id="set-and-expire"><a href="#set-and-expire" class="headerlink" title="set and expire"></a><code>set and expire</code></h3><p>为了解决非原子性操作被中断的问题，在 <code>Redis 2.8</code> 中加入了 <code>setnx</code> 与 <code>expire</code> 组合在一起的原子指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;set lock:distributed true ex 5 nx</span><br><span class="line">OK</span><br><span class="line">...</span><br><span class="line">other code</span><br><span class="line">...</span><br><span class="line">&gt;del lock:distributed</span><br></pre></td></tr></table></figure><p>这种方式保证了加锁并设置有效时间操作的原子性，但是依然有问题。</p><p>假设我们在加锁与释放锁之间的业务代码执行时间超过了设置的有效时间，此时锁会因为超时被释放。会导致两种情况：</p><ol><li>其他节点 B 获取锁之后，执行超时节点 A 执行完成，释放了 B 的锁。</li><li>其它节点获取到了锁，执行临界区代码时就可能会出现并发问题。</li></ol><h3 id="解决锁被其他线程释放问题"><a href="#解决锁被其他线程释放问题" class="headerlink" title="解决锁被其他线程释放问题"></a>解决锁被其他线程释放问题</h3><p>因为在加锁时，各个节点使用的同一个 <code>key</code>，所以会存在超时节点释放了当前加锁节点的锁的情况。这种情况下，可以给加锁的 <code>key</code> 设置一个随机值，删除的时候需要判断 <code>key</code> 当前的 <code>value</code> 是不是等于随机值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val &#x3D; Random.nextInt();</span><br><span class="line">if( redis.set(key,val,true,5) )&#123;</span><br><span class="line">...</span><br><span class="line">other code</span><br><span class="line">...</span><br><span class="line">value &#x3D; redis.get(key);</span><br><span class="line">if(val &#x3D;&#x3D; value)&#123;</span><br><span class="line">redis.delete(key);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码实现了根据随机值删除的逻辑，但是获取 <code>value</code> 直到 <code>delete</code> 指令并非是原子指令，仍然可能有并发问题。这时候需要使用 <code>lua</code> 脚本处理，因为 <code>lua</code> 脚本可以保证连续多个指令原子执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种方式可以避免锁被其他线程释放的问题。</p><h3 id="临界区并发问题"><a href="#临界区并发问题" class="headerlink" title="临界区并发问题"></a>临界区并发问题</h3><p><strong>临界区代码出现并发问题的本质是业务代码执行时间大于锁过期时间。</strong></p><p>我们可以定时刷新加锁时间，保证业务代码在锁过期时间内执行完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isFlushExpiration = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(redis.set(lock, val, NOT_EXIST, SECONDS, <span class="number">20</span>))&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> FlushExpirationTherad());</span><br><span class="line">thread.setDeamon(<span class="keyword">true</span>);</span><br><span class="line">  thread.start();</span><br><span class="line">    ...</span><br><span class="line">    other code</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isFlushExpiration = <span class="keyword">false</span>;</span><br><span class="line">String deleteScript = <span class="string">"if redis.call("</span>get<span class="string">",KEYS[1]) == ARGV[1] then"</span> </span><br><span class="line">    + <span class="string">"return redis.call("</span>del<span class="string">",KEYS[1])"</span></span><br><span class="line">    + <span class="string">"else return 0 end"</span>;</span><br><span class="line">redis.eval(deleteScript,<span class="number">1</span>,key,val);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FlushExpirationTherad</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isFlushExpiration)&#123;</span><br><span class="line">            String checkAndExpireScript = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">                        <span class="string">"return redis.call('expire',KEYS[1],ARGV[2]) "</span> +</span><br><span class="line">                        <span class="string">"else return 0 end"</span>;</span><br><span class="line">            redis.eval(checkAndExpireScript,<span class="number">1</span>,key,val,<span class="string">"20"</span>);</span><br><span class="line">            <span class="comment">// 每隔十秒检查是否完成</span></span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现是用一个线程定期监控客户端是否执行完成。也可以由服务端实现心跳检测机制来保证业务完成（<code>Zookeeper</code>)。</p><p>所以实现单节点 Redis 分布式锁要关注三个关键问题：</p><ol><li>获取锁与设置超时时间实现为原子操作（Redis2.8 开始已支持）</li><li>设置随机字符串保证释放锁时能保证只释放自己持有的锁（给对应的 key 设置随机值）</li><li>判断与释放锁必须实现为原子操作（lua 脚本实现）</li></ol><h2 id="多节点-Redis-分布式锁"><a href="#多节点-Redis-分布式锁" class="headerlink" title="多节点 Redis 分布式锁"></a>多节点 Redis 分布式锁</h2><p>为了保证项目的高可用性，项目一般都配置了 <code>Redis</code> 集群，以防在单节点 <code>Redis</code> 宕机之后，所有客户端都无法获得锁。</p><p>在集群环境下，<code>Redis</code> 存在 <code>failover</code> 机制。当 <code>Master</code> 节点宕机之后，会开始异步的主从复制（<code>replication</code>），这个过程可能会出现以下情况：</p><ol><li>客户端 A 获取了 <code>Master</code> 节点的锁。</li><li><code>Master</code> 节点宕机了，存储锁的 <code>key</code> 暂未同步到 <code>Slave</code> 上。</li><li><code>Slave</code> 节点升级为 <code>Master</code> 节点。</li><li>客户端 B 从新的 <code>Master</code> 节点上获取到了同一资源的锁。</li></ol><p>在这种情况下，锁的安全性就会被打破，<code>Redis</code> 作者 <code>antirez</code> 针对此问题设计了 <code>Redlock</code> 算法。</p><h3 id="Redlock-算法"><a href="#Redlock-算法" class="headerlink" title="Redlock 算法"></a>Redlock 算法</h3><p><code>Redlock</code> 算法获取锁时客户端执行步骤：</p><ol><li>获取当前时间（start）。</li><li>依次向 N 个 <code>Redis</code> 节点请求锁。请求锁的方式与从单节点 <code>Redis</code> 获取锁的方式一致。为了保证在某个 <code>Redis</code> 节点不可用时该算法能够继续运行，获取锁的操作都需要设置超时时间，需要保证该超时时间远小于锁的有效时间。这样才能保证客户端在向某个 <code>Redis</code> 节点获取锁失败之后，可以立刻尝试下一个节点。</li><li>计算获取锁的过程总共消耗多长时间（consumeTime = end - start）。如果客户端从大多数 <code>Redis</code> 节点（&gt;= N/2 + 1) 成功获取锁，并且获取锁总时长没有超过锁的有效时间，这种情况下，客户端会认为获取锁成功，否则，获取锁失败。</li><li>如果最终获取锁成功，锁的有效时间应该重新设置为锁最初的有效时间减去 <code>consumeTime</code>。</li><li>如果最终获取锁失败，客户端应该立刻向所有 <code>Redis</code> 节点发起释放锁的请求。</li></ol><p>在释放锁时，需要向<strong>所有 <code>Redis</code> 节点</strong>发起释放锁的操作，不管节点是否获取锁成功。因为可能存在客户端向 <code>Redis</code> 节点获取锁时成功，但节点通知客户端时通信失败，客户端会认为该节点加锁失败。</p><p><code>Redlock</code> 算法实现了更高的可用性，也不会出现 <code>failover</code> 时失效的问题。但是如果有节点崩溃重启，仍然对锁的安全性有影响。假设共有 5 个 <code>Redis</code> 节点 A、B、C、D、E：</p><ol><li>客户端 A 获取了 A、B、C 节点的锁，但 D 与 E 节点的锁获取失败。</li><li>节点 C 崩溃重启，但是客户端 A 在 C 上加的锁没有持久化下来，重启后丢失</li><li>节点 C 重启后，客户端 B 锁住了 C、D、E，获取锁成功。</li></ol><p>在这种情况下，客户端 A 与 B 都获取了访问同一资源的锁。</p><blockquote><p>这里第 2 步中节点 C 锁丢失的问题可能由多种原因引起。默认情况下，<code>Redis</code> 的 <code>AOF</code> 持久化方式是每秒写一次磁盘（fsync），这情况下就有可能丢失 1 秒的数据。我们也可以设置每次操作都触发 <code>fsync</code>，这会影响性能，不过即使这样设置，也有可能由于操作系统的问题导致操作写入失败。</p></blockquote><p>为了解决节点重启导致的锁失效问题，<code>antirez</code> 提出了延迟重启的概念，即当一个节点崩溃之后并不立即重启，而是等待与分布式锁相关的 <code>key</code> 的有效时间都过期之后再重启，这样在该节点重启后也不会对现有的锁造成影响。</p><h3 id="一些插曲"><a href="#一些插曲" class="headerlink" title="一些插曲"></a>一些插曲</h3><p>关于 <code>Redlock</code> 的安全性问题，在分布式系统专家 Martin Kleppmann 和 <code>Redis</code> 的作者 antirez 之间发生过一场争论，这个问题引发了激烈的讨论。关于这场争论的内容可以关注 <a href="http://zhangtielei.com/posts/blog-redlock-reasoning.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗</a> 这篇文章。<br>最后得出的结论是 <code>Redlock</code> 在效率要求的应用中是合理的，所以在 <code>Java</code> 项目中可以使用 <code>Redlock</code> 的 <code>Java</code> 版本 <code>Redission</code> 来控制多节点访问共享资源。但是仍有极端情况会造成 <code>Redlock</code> 的不安全，我们应该知道它在安全性上有哪些不足以及会造成什么后果。如果需要进一步的追求正确性，可以使用 <code>Zookeeper</code> 分布式锁。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul><li><a href="http://zhangtielei.com/posts/blog-redlock-reasoning-part2.html" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在单节点中，需要用并发线程都能访问到的资源的状态变化来控制同步。在分布式应用中，使用应用所有节点都能访问到的 &lt;code&gt;Redis&lt;/code&gt; 中的某个 &lt;code&gt;key&lt;/code&gt; 来控制多节点访问。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="http://changleamazing.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://changleamazing.com/tags/Redis/"/>
    
      <category term="Distributed Lock" scheme="http://changleamazing.com/tags/Distributed-Lock/"/>
    
      <category term="Distributed System" scheme="http://changleamazing.com/tags/Distributed-System/"/>
    
  </entry>
  
</feed>
